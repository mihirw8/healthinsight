
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model HealthReport
 * 
 */
export type HealthReport = $Result.DefaultSelection<Prisma.$HealthReportPayload>
/**
 * Model BiomarkerValue
 * 
 */
export type BiomarkerValue = $Result.DefaultSelection<Prisma.$BiomarkerValuePayload>
/**
 * Model Biomarker
 * 
 */
export type Biomarker = $Result.DefaultSelection<Prisma.$BiomarkerPayload>
/**
 * Model Symptom
 * 
 */
export type Symptom = $Result.DefaultSelection<Prisma.$SymptomPayload>
/**
 * Model Medication
 * 
 */
export type Medication = $Result.DefaultSelection<Prisma.$MedicationPayload>
/**
 * Model Correlation
 * 
 */
export type Correlation = $Result.DefaultSelection<Prisma.$CorrelationPayload>
/**
 * Model RiskAssessment
 * 
 */
export type RiskAssessment = $Result.DefaultSelection<Prisma.$RiskAssessmentPayload>
/**
 * Model Recommendation
 * 
 */
export type Recommendation = $Result.DefaultSelection<Prisma.$RecommendationPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.healthReport`: Exposes CRUD operations for the **HealthReport** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HealthReports
    * const healthReports = await prisma.healthReport.findMany()
    * ```
    */
  get healthReport(): Prisma.HealthReportDelegate<ExtArgs>;

  /**
   * `prisma.biomarkerValue`: Exposes CRUD operations for the **BiomarkerValue** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BiomarkerValues
    * const biomarkerValues = await prisma.biomarkerValue.findMany()
    * ```
    */
  get biomarkerValue(): Prisma.BiomarkerValueDelegate<ExtArgs>;

  /**
   * `prisma.biomarker`: Exposes CRUD operations for the **Biomarker** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Biomarkers
    * const biomarkers = await prisma.biomarker.findMany()
    * ```
    */
  get biomarker(): Prisma.BiomarkerDelegate<ExtArgs>;

  /**
   * `prisma.symptom`: Exposes CRUD operations for the **Symptom** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Symptoms
    * const symptoms = await prisma.symptom.findMany()
    * ```
    */
  get symptom(): Prisma.SymptomDelegate<ExtArgs>;

  /**
   * `prisma.medication`: Exposes CRUD operations for the **Medication** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Medications
    * const medications = await prisma.medication.findMany()
    * ```
    */
  get medication(): Prisma.MedicationDelegate<ExtArgs>;

  /**
   * `prisma.correlation`: Exposes CRUD operations for the **Correlation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Correlations
    * const correlations = await prisma.correlation.findMany()
    * ```
    */
  get correlation(): Prisma.CorrelationDelegate<ExtArgs>;

  /**
   * `prisma.riskAssessment`: Exposes CRUD operations for the **RiskAssessment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RiskAssessments
    * const riskAssessments = await prisma.riskAssessment.findMany()
    * ```
    */
  get riskAssessment(): Prisma.RiskAssessmentDelegate<ExtArgs>;

  /**
   * `prisma.recommendation`: Exposes CRUD operations for the **Recommendation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Recommendations
    * const recommendations = await prisma.recommendation.findMany()
    * ```
    */
  get recommendation(): Prisma.RecommendationDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    HealthReport: 'HealthReport',
    BiomarkerValue: 'BiomarkerValue',
    Biomarker: 'Biomarker',
    Symptom: 'Symptom',
    Medication: 'Medication',
    Correlation: 'Correlation',
    RiskAssessment: 'RiskAssessment',
    Recommendation: 'Recommendation'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "healthReport" | "biomarkerValue" | "biomarker" | "symptom" | "medication" | "correlation" | "riskAssessment" | "recommendation"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      HealthReport: {
        payload: Prisma.$HealthReportPayload<ExtArgs>
        fields: Prisma.HealthReportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HealthReportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthReportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HealthReportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthReportPayload>
          }
          findFirst: {
            args: Prisma.HealthReportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthReportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HealthReportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthReportPayload>
          }
          findMany: {
            args: Prisma.HealthReportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthReportPayload>[]
          }
          create: {
            args: Prisma.HealthReportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthReportPayload>
          }
          createMany: {
            args: Prisma.HealthReportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HealthReportCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthReportPayload>[]
          }
          delete: {
            args: Prisma.HealthReportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthReportPayload>
          }
          update: {
            args: Prisma.HealthReportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthReportPayload>
          }
          deleteMany: {
            args: Prisma.HealthReportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HealthReportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.HealthReportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthReportPayload>
          }
          aggregate: {
            args: Prisma.HealthReportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHealthReport>
          }
          groupBy: {
            args: Prisma.HealthReportGroupByArgs<ExtArgs>
            result: $Utils.Optional<HealthReportGroupByOutputType>[]
          }
          count: {
            args: Prisma.HealthReportCountArgs<ExtArgs>
            result: $Utils.Optional<HealthReportCountAggregateOutputType> | number
          }
        }
      }
      BiomarkerValue: {
        payload: Prisma.$BiomarkerValuePayload<ExtArgs>
        fields: Prisma.BiomarkerValueFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BiomarkerValueFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BiomarkerValuePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BiomarkerValueFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BiomarkerValuePayload>
          }
          findFirst: {
            args: Prisma.BiomarkerValueFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BiomarkerValuePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BiomarkerValueFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BiomarkerValuePayload>
          }
          findMany: {
            args: Prisma.BiomarkerValueFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BiomarkerValuePayload>[]
          }
          create: {
            args: Prisma.BiomarkerValueCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BiomarkerValuePayload>
          }
          createMany: {
            args: Prisma.BiomarkerValueCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BiomarkerValueCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BiomarkerValuePayload>[]
          }
          delete: {
            args: Prisma.BiomarkerValueDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BiomarkerValuePayload>
          }
          update: {
            args: Prisma.BiomarkerValueUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BiomarkerValuePayload>
          }
          deleteMany: {
            args: Prisma.BiomarkerValueDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BiomarkerValueUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BiomarkerValueUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BiomarkerValuePayload>
          }
          aggregate: {
            args: Prisma.BiomarkerValueAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBiomarkerValue>
          }
          groupBy: {
            args: Prisma.BiomarkerValueGroupByArgs<ExtArgs>
            result: $Utils.Optional<BiomarkerValueGroupByOutputType>[]
          }
          count: {
            args: Prisma.BiomarkerValueCountArgs<ExtArgs>
            result: $Utils.Optional<BiomarkerValueCountAggregateOutputType> | number
          }
        }
      }
      Biomarker: {
        payload: Prisma.$BiomarkerPayload<ExtArgs>
        fields: Prisma.BiomarkerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BiomarkerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BiomarkerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BiomarkerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BiomarkerPayload>
          }
          findFirst: {
            args: Prisma.BiomarkerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BiomarkerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BiomarkerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BiomarkerPayload>
          }
          findMany: {
            args: Prisma.BiomarkerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BiomarkerPayload>[]
          }
          create: {
            args: Prisma.BiomarkerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BiomarkerPayload>
          }
          createMany: {
            args: Prisma.BiomarkerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BiomarkerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BiomarkerPayload>[]
          }
          delete: {
            args: Prisma.BiomarkerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BiomarkerPayload>
          }
          update: {
            args: Prisma.BiomarkerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BiomarkerPayload>
          }
          deleteMany: {
            args: Prisma.BiomarkerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BiomarkerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BiomarkerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BiomarkerPayload>
          }
          aggregate: {
            args: Prisma.BiomarkerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBiomarker>
          }
          groupBy: {
            args: Prisma.BiomarkerGroupByArgs<ExtArgs>
            result: $Utils.Optional<BiomarkerGroupByOutputType>[]
          }
          count: {
            args: Prisma.BiomarkerCountArgs<ExtArgs>
            result: $Utils.Optional<BiomarkerCountAggregateOutputType> | number
          }
        }
      }
      Symptom: {
        payload: Prisma.$SymptomPayload<ExtArgs>
        fields: Prisma.SymptomFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SymptomFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SymptomPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SymptomFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SymptomPayload>
          }
          findFirst: {
            args: Prisma.SymptomFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SymptomPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SymptomFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SymptomPayload>
          }
          findMany: {
            args: Prisma.SymptomFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SymptomPayload>[]
          }
          create: {
            args: Prisma.SymptomCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SymptomPayload>
          }
          createMany: {
            args: Prisma.SymptomCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SymptomCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SymptomPayload>[]
          }
          delete: {
            args: Prisma.SymptomDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SymptomPayload>
          }
          update: {
            args: Prisma.SymptomUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SymptomPayload>
          }
          deleteMany: {
            args: Prisma.SymptomDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SymptomUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SymptomUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SymptomPayload>
          }
          aggregate: {
            args: Prisma.SymptomAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSymptom>
          }
          groupBy: {
            args: Prisma.SymptomGroupByArgs<ExtArgs>
            result: $Utils.Optional<SymptomGroupByOutputType>[]
          }
          count: {
            args: Prisma.SymptomCountArgs<ExtArgs>
            result: $Utils.Optional<SymptomCountAggregateOutputType> | number
          }
        }
      }
      Medication: {
        payload: Prisma.$MedicationPayload<ExtArgs>
        fields: Prisma.MedicationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MedicationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MedicationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationPayload>
          }
          findFirst: {
            args: Prisma.MedicationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MedicationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationPayload>
          }
          findMany: {
            args: Prisma.MedicationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationPayload>[]
          }
          create: {
            args: Prisma.MedicationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationPayload>
          }
          createMany: {
            args: Prisma.MedicationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MedicationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationPayload>[]
          }
          delete: {
            args: Prisma.MedicationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationPayload>
          }
          update: {
            args: Prisma.MedicationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationPayload>
          }
          deleteMany: {
            args: Prisma.MedicationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MedicationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MedicationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationPayload>
          }
          aggregate: {
            args: Prisma.MedicationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMedication>
          }
          groupBy: {
            args: Prisma.MedicationGroupByArgs<ExtArgs>
            result: $Utils.Optional<MedicationGroupByOutputType>[]
          }
          count: {
            args: Prisma.MedicationCountArgs<ExtArgs>
            result: $Utils.Optional<MedicationCountAggregateOutputType> | number
          }
        }
      }
      Correlation: {
        payload: Prisma.$CorrelationPayload<ExtArgs>
        fields: Prisma.CorrelationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CorrelationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CorrelationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CorrelationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CorrelationPayload>
          }
          findFirst: {
            args: Prisma.CorrelationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CorrelationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CorrelationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CorrelationPayload>
          }
          findMany: {
            args: Prisma.CorrelationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CorrelationPayload>[]
          }
          create: {
            args: Prisma.CorrelationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CorrelationPayload>
          }
          createMany: {
            args: Prisma.CorrelationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CorrelationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CorrelationPayload>[]
          }
          delete: {
            args: Prisma.CorrelationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CorrelationPayload>
          }
          update: {
            args: Prisma.CorrelationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CorrelationPayload>
          }
          deleteMany: {
            args: Prisma.CorrelationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CorrelationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CorrelationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CorrelationPayload>
          }
          aggregate: {
            args: Prisma.CorrelationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCorrelation>
          }
          groupBy: {
            args: Prisma.CorrelationGroupByArgs<ExtArgs>
            result: $Utils.Optional<CorrelationGroupByOutputType>[]
          }
          count: {
            args: Prisma.CorrelationCountArgs<ExtArgs>
            result: $Utils.Optional<CorrelationCountAggregateOutputType> | number
          }
        }
      }
      RiskAssessment: {
        payload: Prisma.$RiskAssessmentPayload<ExtArgs>
        fields: Prisma.RiskAssessmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RiskAssessmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskAssessmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RiskAssessmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskAssessmentPayload>
          }
          findFirst: {
            args: Prisma.RiskAssessmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskAssessmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RiskAssessmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskAssessmentPayload>
          }
          findMany: {
            args: Prisma.RiskAssessmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskAssessmentPayload>[]
          }
          create: {
            args: Prisma.RiskAssessmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskAssessmentPayload>
          }
          createMany: {
            args: Prisma.RiskAssessmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RiskAssessmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskAssessmentPayload>[]
          }
          delete: {
            args: Prisma.RiskAssessmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskAssessmentPayload>
          }
          update: {
            args: Prisma.RiskAssessmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskAssessmentPayload>
          }
          deleteMany: {
            args: Prisma.RiskAssessmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RiskAssessmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RiskAssessmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskAssessmentPayload>
          }
          aggregate: {
            args: Prisma.RiskAssessmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRiskAssessment>
          }
          groupBy: {
            args: Prisma.RiskAssessmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<RiskAssessmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.RiskAssessmentCountArgs<ExtArgs>
            result: $Utils.Optional<RiskAssessmentCountAggregateOutputType> | number
          }
        }
      }
      Recommendation: {
        payload: Prisma.$RecommendationPayload<ExtArgs>
        fields: Prisma.RecommendationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RecommendationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecommendationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RecommendationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecommendationPayload>
          }
          findFirst: {
            args: Prisma.RecommendationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecommendationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RecommendationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecommendationPayload>
          }
          findMany: {
            args: Prisma.RecommendationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecommendationPayload>[]
          }
          create: {
            args: Prisma.RecommendationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecommendationPayload>
          }
          createMany: {
            args: Prisma.RecommendationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RecommendationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecommendationPayload>[]
          }
          delete: {
            args: Prisma.RecommendationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecommendationPayload>
          }
          update: {
            args: Prisma.RecommendationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecommendationPayload>
          }
          deleteMany: {
            args: Prisma.RecommendationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RecommendationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RecommendationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecommendationPayload>
          }
          aggregate: {
            args: Prisma.RecommendationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRecommendation>
          }
          groupBy: {
            args: Prisma.RecommendationGroupByArgs<ExtArgs>
            result: $Utils.Optional<RecommendationGroupByOutputType>[]
          }
          count: {
            args: Prisma.RecommendationCountArgs<ExtArgs>
            result: $Utils.Optional<RecommendationCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    healthReports: number
    symptoms: number
    medications: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    healthReports?: boolean | UserCountOutputTypeCountHealthReportsArgs
    symptoms?: boolean | UserCountOutputTypeCountSymptomsArgs
    medications?: boolean | UserCountOutputTypeCountMedicationsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountHealthReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HealthReportWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSymptomsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SymptomWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMedicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicationWhereInput
  }


  /**
   * Count Type HealthReportCountOutputType
   */

  export type HealthReportCountOutputType = {
    biomarkers: number
  }

  export type HealthReportCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    biomarkers?: boolean | HealthReportCountOutputTypeCountBiomarkersArgs
  }

  // Custom InputTypes
  /**
   * HealthReportCountOutputType without action
   */
  export type HealthReportCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthReportCountOutputType
     */
    select?: HealthReportCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * HealthReportCountOutputType without action
   */
  export type HealthReportCountOutputTypeCountBiomarkersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BiomarkerValueWhereInput
  }


  /**
   * Count Type BiomarkerCountOutputType
   */

  export type BiomarkerCountOutputType = {
    values: number
    correlations: number
  }

  export type BiomarkerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    values?: boolean | BiomarkerCountOutputTypeCountValuesArgs
    correlations?: boolean | BiomarkerCountOutputTypeCountCorrelationsArgs
  }

  // Custom InputTypes
  /**
   * BiomarkerCountOutputType without action
   */
  export type BiomarkerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BiomarkerCountOutputType
     */
    select?: BiomarkerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BiomarkerCountOutputType without action
   */
  export type BiomarkerCountOutputTypeCountValuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BiomarkerValueWhereInput
  }

  /**
   * BiomarkerCountOutputType without action
   */
  export type BiomarkerCountOutputTypeCountCorrelationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CorrelationWhereInput
  }


  /**
   * Count Type SymptomCountOutputType
   */

  export type SymptomCountOutputType = {
    correlations: number
  }

  export type SymptomCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    correlations?: boolean | SymptomCountOutputTypeCountCorrelationsArgs
  }

  // Custom InputTypes
  /**
   * SymptomCountOutputType without action
   */
  export type SymptomCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SymptomCountOutputType
     */
    select?: SymptomCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SymptomCountOutputType without action
   */
  export type SymptomCountOutputTypeCountCorrelationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CorrelationWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    dateOfBirth: Date | null
    sex: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    dateOfBirth: Date | null
    sex: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    name: number
    dateOfBirth: number
    sex: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    name?: true
    dateOfBirth?: true
    sex?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    name?: true
    dateOfBirth?: true
    sex?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    name?: true
    dateOfBirth?: true
    sex?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    name: string | null
    dateOfBirth: Date | null
    sex: string | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    dateOfBirth?: boolean
    sex?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    healthReports?: boolean | User$healthReportsArgs<ExtArgs>
    symptoms?: boolean | User$symptomsArgs<ExtArgs>
    medications?: boolean | User$medicationsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    dateOfBirth?: boolean
    sex?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    name?: boolean
    dateOfBirth?: boolean
    sex?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    healthReports?: boolean | User$healthReportsArgs<ExtArgs>
    symptoms?: boolean | User$symptomsArgs<ExtArgs>
    medications?: boolean | User$medicationsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      healthReports: Prisma.$HealthReportPayload<ExtArgs>[]
      symptoms: Prisma.$SymptomPayload<ExtArgs>[]
      medications: Prisma.$MedicationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      name: string | null
      dateOfBirth: Date | null
      sex: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    healthReports<T extends User$healthReportsArgs<ExtArgs> = {}>(args?: Subset<T, User$healthReportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HealthReportPayload<ExtArgs>, T, "findMany"> | Null>
    symptoms<T extends User$symptomsArgs<ExtArgs> = {}>(args?: Subset<T, User$symptomsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SymptomPayload<ExtArgs>, T, "findMany"> | Null>
    medications<T extends User$medicationsArgs<ExtArgs> = {}>(args?: Subset<T, User$medicationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicationPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly dateOfBirth: FieldRef<"User", 'DateTime'>
    readonly sex: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.healthReports
   */
  export type User$healthReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthReport
     */
    select?: HealthReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthReportInclude<ExtArgs> | null
    where?: HealthReportWhereInput
    orderBy?: HealthReportOrderByWithRelationInput | HealthReportOrderByWithRelationInput[]
    cursor?: HealthReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HealthReportScalarFieldEnum | HealthReportScalarFieldEnum[]
  }

  /**
   * User.symptoms
   */
  export type User$symptomsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Symptom
     */
    select?: SymptomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SymptomInclude<ExtArgs> | null
    where?: SymptomWhereInput
    orderBy?: SymptomOrderByWithRelationInput | SymptomOrderByWithRelationInput[]
    cursor?: SymptomWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SymptomScalarFieldEnum | SymptomScalarFieldEnum[]
  }

  /**
   * User.medications
   */
  export type User$medicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medication
     */
    select?: MedicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationInclude<ExtArgs> | null
    where?: MedicationWhereInput
    orderBy?: MedicationOrderByWithRelationInput | MedicationOrderByWithRelationInput[]
    cursor?: MedicationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MedicationScalarFieldEnum | MedicationScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model HealthReport
   */

  export type AggregateHealthReport = {
    _count: HealthReportCountAggregateOutputType | null
    _min: HealthReportMinAggregateOutputType | null
    _max: HealthReportMaxAggregateOutputType | null
  }

  export type HealthReportMinAggregateOutputType = {
    id: string | null
    userId: string | null
    reportType: string | null
    collectionDate: Date | null
    provider: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HealthReportMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    reportType: string | null
    collectionDate: Date | null
    provider: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HealthReportCountAggregateOutputType = {
    id: number
    userId: number
    reportType: number
    collectionDate: number
    provider: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type HealthReportMinAggregateInputType = {
    id?: true
    userId?: true
    reportType?: true
    collectionDate?: true
    provider?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HealthReportMaxAggregateInputType = {
    id?: true
    userId?: true
    reportType?: true
    collectionDate?: true
    provider?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HealthReportCountAggregateInputType = {
    id?: true
    userId?: true
    reportType?: true
    collectionDate?: true
    provider?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type HealthReportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HealthReport to aggregate.
     */
    where?: HealthReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HealthReports to fetch.
     */
    orderBy?: HealthReportOrderByWithRelationInput | HealthReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HealthReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HealthReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HealthReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HealthReports
    **/
    _count?: true | HealthReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HealthReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HealthReportMaxAggregateInputType
  }

  export type GetHealthReportAggregateType<T extends HealthReportAggregateArgs> = {
        [P in keyof T & keyof AggregateHealthReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHealthReport[P]>
      : GetScalarType<T[P], AggregateHealthReport[P]>
  }




  export type HealthReportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HealthReportWhereInput
    orderBy?: HealthReportOrderByWithAggregationInput | HealthReportOrderByWithAggregationInput[]
    by: HealthReportScalarFieldEnum[] | HealthReportScalarFieldEnum
    having?: HealthReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HealthReportCountAggregateInputType | true
    _min?: HealthReportMinAggregateInputType
    _max?: HealthReportMaxAggregateInputType
  }

  export type HealthReportGroupByOutputType = {
    id: string
    userId: string
    reportType: string
    collectionDate: Date
    provider: string | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: HealthReportCountAggregateOutputType | null
    _min: HealthReportMinAggregateOutputType | null
    _max: HealthReportMaxAggregateOutputType | null
  }

  type GetHealthReportGroupByPayload<T extends HealthReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HealthReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HealthReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HealthReportGroupByOutputType[P]>
            : GetScalarType<T[P], HealthReportGroupByOutputType[P]>
        }
      >
    >


  export type HealthReportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    reportType?: boolean
    collectionDate?: boolean
    provider?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    biomarkers?: boolean | HealthReport$biomarkersArgs<ExtArgs>
    _count?: boolean | HealthReportCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["healthReport"]>

  export type HealthReportSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    reportType?: boolean
    collectionDate?: boolean
    provider?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["healthReport"]>

  export type HealthReportSelectScalar = {
    id?: boolean
    userId?: boolean
    reportType?: boolean
    collectionDate?: boolean
    provider?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type HealthReportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    biomarkers?: boolean | HealthReport$biomarkersArgs<ExtArgs>
    _count?: boolean | HealthReportCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type HealthReportIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $HealthReportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HealthReport"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      biomarkers: Prisma.$BiomarkerValuePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      reportType: string
      collectionDate: Date
      provider: string | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["healthReport"]>
    composites: {}
  }

  type HealthReportGetPayload<S extends boolean | null | undefined | HealthReportDefaultArgs> = $Result.GetResult<Prisma.$HealthReportPayload, S>

  type HealthReportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<HealthReportFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: HealthReportCountAggregateInputType | true
    }

  export interface HealthReportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HealthReport'], meta: { name: 'HealthReport' } }
    /**
     * Find zero or one HealthReport that matches the filter.
     * @param {HealthReportFindUniqueArgs} args - Arguments to find a HealthReport
     * @example
     * // Get one HealthReport
     * const healthReport = await prisma.healthReport.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HealthReportFindUniqueArgs>(args: SelectSubset<T, HealthReportFindUniqueArgs<ExtArgs>>): Prisma__HealthReportClient<$Result.GetResult<Prisma.$HealthReportPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one HealthReport that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {HealthReportFindUniqueOrThrowArgs} args - Arguments to find a HealthReport
     * @example
     * // Get one HealthReport
     * const healthReport = await prisma.healthReport.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HealthReportFindUniqueOrThrowArgs>(args: SelectSubset<T, HealthReportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HealthReportClient<$Result.GetResult<Prisma.$HealthReportPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first HealthReport that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HealthReportFindFirstArgs} args - Arguments to find a HealthReport
     * @example
     * // Get one HealthReport
     * const healthReport = await prisma.healthReport.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HealthReportFindFirstArgs>(args?: SelectSubset<T, HealthReportFindFirstArgs<ExtArgs>>): Prisma__HealthReportClient<$Result.GetResult<Prisma.$HealthReportPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first HealthReport that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HealthReportFindFirstOrThrowArgs} args - Arguments to find a HealthReport
     * @example
     * // Get one HealthReport
     * const healthReport = await prisma.healthReport.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HealthReportFindFirstOrThrowArgs>(args?: SelectSubset<T, HealthReportFindFirstOrThrowArgs<ExtArgs>>): Prisma__HealthReportClient<$Result.GetResult<Prisma.$HealthReportPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more HealthReports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HealthReportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HealthReports
     * const healthReports = await prisma.healthReport.findMany()
     * 
     * // Get first 10 HealthReports
     * const healthReports = await prisma.healthReport.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const healthReportWithIdOnly = await prisma.healthReport.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HealthReportFindManyArgs>(args?: SelectSubset<T, HealthReportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HealthReportPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a HealthReport.
     * @param {HealthReportCreateArgs} args - Arguments to create a HealthReport.
     * @example
     * // Create one HealthReport
     * const HealthReport = await prisma.healthReport.create({
     *   data: {
     *     // ... data to create a HealthReport
     *   }
     * })
     * 
     */
    create<T extends HealthReportCreateArgs>(args: SelectSubset<T, HealthReportCreateArgs<ExtArgs>>): Prisma__HealthReportClient<$Result.GetResult<Prisma.$HealthReportPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many HealthReports.
     * @param {HealthReportCreateManyArgs} args - Arguments to create many HealthReports.
     * @example
     * // Create many HealthReports
     * const healthReport = await prisma.healthReport.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HealthReportCreateManyArgs>(args?: SelectSubset<T, HealthReportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many HealthReports and returns the data saved in the database.
     * @param {HealthReportCreateManyAndReturnArgs} args - Arguments to create many HealthReports.
     * @example
     * // Create many HealthReports
     * const healthReport = await prisma.healthReport.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many HealthReports and only return the `id`
     * const healthReportWithIdOnly = await prisma.healthReport.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HealthReportCreateManyAndReturnArgs>(args?: SelectSubset<T, HealthReportCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HealthReportPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a HealthReport.
     * @param {HealthReportDeleteArgs} args - Arguments to delete one HealthReport.
     * @example
     * // Delete one HealthReport
     * const HealthReport = await prisma.healthReport.delete({
     *   where: {
     *     // ... filter to delete one HealthReport
     *   }
     * })
     * 
     */
    delete<T extends HealthReportDeleteArgs>(args: SelectSubset<T, HealthReportDeleteArgs<ExtArgs>>): Prisma__HealthReportClient<$Result.GetResult<Prisma.$HealthReportPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one HealthReport.
     * @param {HealthReportUpdateArgs} args - Arguments to update one HealthReport.
     * @example
     * // Update one HealthReport
     * const healthReport = await prisma.healthReport.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HealthReportUpdateArgs>(args: SelectSubset<T, HealthReportUpdateArgs<ExtArgs>>): Prisma__HealthReportClient<$Result.GetResult<Prisma.$HealthReportPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more HealthReports.
     * @param {HealthReportDeleteManyArgs} args - Arguments to filter HealthReports to delete.
     * @example
     * // Delete a few HealthReports
     * const { count } = await prisma.healthReport.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HealthReportDeleteManyArgs>(args?: SelectSubset<T, HealthReportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HealthReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HealthReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HealthReports
     * const healthReport = await prisma.healthReport.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HealthReportUpdateManyArgs>(args: SelectSubset<T, HealthReportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one HealthReport.
     * @param {HealthReportUpsertArgs} args - Arguments to update or create a HealthReport.
     * @example
     * // Update or create a HealthReport
     * const healthReport = await prisma.healthReport.upsert({
     *   create: {
     *     // ... data to create a HealthReport
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HealthReport we want to update
     *   }
     * })
     */
    upsert<T extends HealthReportUpsertArgs>(args: SelectSubset<T, HealthReportUpsertArgs<ExtArgs>>): Prisma__HealthReportClient<$Result.GetResult<Prisma.$HealthReportPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of HealthReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HealthReportCountArgs} args - Arguments to filter HealthReports to count.
     * @example
     * // Count the number of HealthReports
     * const count = await prisma.healthReport.count({
     *   where: {
     *     // ... the filter for the HealthReports we want to count
     *   }
     * })
    **/
    count<T extends HealthReportCountArgs>(
      args?: Subset<T, HealthReportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HealthReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HealthReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HealthReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HealthReportAggregateArgs>(args: Subset<T, HealthReportAggregateArgs>): Prisma.PrismaPromise<GetHealthReportAggregateType<T>>

    /**
     * Group by HealthReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HealthReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HealthReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HealthReportGroupByArgs['orderBy'] }
        : { orderBy?: HealthReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HealthReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHealthReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HealthReport model
   */
  readonly fields: HealthReportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HealthReport.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HealthReportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    biomarkers<T extends HealthReport$biomarkersArgs<ExtArgs> = {}>(args?: Subset<T, HealthReport$biomarkersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BiomarkerValuePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the HealthReport model
   */ 
  interface HealthReportFieldRefs {
    readonly id: FieldRef<"HealthReport", 'String'>
    readonly userId: FieldRef<"HealthReport", 'String'>
    readonly reportType: FieldRef<"HealthReport", 'String'>
    readonly collectionDate: FieldRef<"HealthReport", 'DateTime'>
    readonly provider: FieldRef<"HealthReport", 'String'>
    readonly notes: FieldRef<"HealthReport", 'String'>
    readonly createdAt: FieldRef<"HealthReport", 'DateTime'>
    readonly updatedAt: FieldRef<"HealthReport", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * HealthReport findUnique
   */
  export type HealthReportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthReport
     */
    select?: HealthReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthReportInclude<ExtArgs> | null
    /**
     * Filter, which HealthReport to fetch.
     */
    where: HealthReportWhereUniqueInput
  }

  /**
   * HealthReport findUniqueOrThrow
   */
  export type HealthReportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthReport
     */
    select?: HealthReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthReportInclude<ExtArgs> | null
    /**
     * Filter, which HealthReport to fetch.
     */
    where: HealthReportWhereUniqueInput
  }

  /**
   * HealthReport findFirst
   */
  export type HealthReportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthReport
     */
    select?: HealthReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthReportInclude<ExtArgs> | null
    /**
     * Filter, which HealthReport to fetch.
     */
    where?: HealthReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HealthReports to fetch.
     */
    orderBy?: HealthReportOrderByWithRelationInput | HealthReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HealthReports.
     */
    cursor?: HealthReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HealthReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HealthReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HealthReports.
     */
    distinct?: HealthReportScalarFieldEnum | HealthReportScalarFieldEnum[]
  }

  /**
   * HealthReport findFirstOrThrow
   */
  export type HealthReportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthReport
     */
    select?: HealthReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthReportInclude<ExtArgs> | null
    /**
     * Filter, which HealthReport to fetch.
     */
    where?: HealthReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HealthReports to fetch.
     */
    orderBy?: HealthReportOrderByWithRelationInput | HealthReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HealthReports.
     */
    cursor?: HealthReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HealthReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HealthReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HealthReports.
     */
    distinct?: HealthReportScalarFieldEnum | HealthReportScalarFieldEnum[]
  }

  /**
   * HealthReport findMany
   */
  export type HealthReportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthReport
     */
    select?: HealthReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthReportInclude<ExtArgs> | null
    /**
     * Filter, which HealthReports to fetch.
     */
    where?: HealthReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HealthReports to fetch.
     */
    orderBy?: HealthReportOrderByWithRelationInput | HealthReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HealthReports.
     */
    cursor?: HealthReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HealthReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HealthReports.
     */
    skip?: number
    distinct?: HealthReportScalarFieldEnum | HealthReportScalarFieldEnum[]
  }

  /**
   * HealthReport create
   */
  export type HealthReportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthReport
     */
    select?: HealthReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthReportInclude<ExtArgs> | null
    /**
     * The data needed to create a HealthReport.
     */
    data: XOR<HealthReportCreateInput, HealthReportUncheckedCreateInput>
  }

  /**
   * HealthReport createMany
   */
  export type HealthReportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HealthReports.
     */
    data: HealthReportCreateManyInput | HealthReportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * HealthReport createManyAndReturn
   */
  export type HealthReportCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthReport
     */
    select?: HealthReportSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many HealthReports.
     */
    data: HealthReportCreateManyInput | HealthReportCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthReportIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * HealthReport update
   */
  export type HealthReportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthReport
     */
    select?: HealthReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthReportInclude<ExtArgs> | null
    /**
     * The data needed to update a HealthReport.
     */
    data: XOR<HealthReportUpdateInput, HealthReportUncheckedUpdateInput>
    /**
     * Choose, which HealthReport to update.
     */
    where: HealthReportWhereUniqueInput
  }

  /**
   * HealthReport updateMany
   */
  export type HealthReportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HealthReports.
     */
    data: XOR<HealthReportUpdateManyMutationInput, HealthReportUncheckedUpdateManyInput>
    /**
     * Filter which HealthReports to update
     */
    where?: HealthReportWhereInput
  }

  /**
   * HealthReport upsert
   */
  export type HealthReportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthReport
     */
    select?: HealthReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthReportInclude<ExtArgs> | null
    /**
     * The filter to search for the HealthReport to update in case it exists.
     */
    where: HealthReportWhereUniqueInput
    /**
     * In case the HealthReport found by the `where` argument doesn't exist, create a new HealthReport with this data.
     */
    create: XOR<HealthReportCreateInput, HealthReportUncheckedCreateInput>
    /**
     * In case the HealthReport was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HealthReportUpdateInput, HealthReportUncheckedUpdateInput>
  }

  /**
   * HealthReport delete
   */
  export type HealthReportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthReport
     */
    select?: HealthReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthReportInclude<ExtArgs> | null
    /**
     * Filter which HealthReport to delete.
     */
    where: HealthReportWhereUniqueInput
  }

  /**
   * HealthReport deleteMany
   */
  export type HealthReportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HealthReports to delete
     */
    where?: HealthReportWhereInput
  }

  /**
   * HealthReport.biomarkers
   */
  export type HealthReport$biomarkersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BiomarkerValue
     */
    select?: BiomarkerValueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiomarkerValueInclude<ExtArgs> | null
    where?: BiomarkerValueWhereInput
    orderBy?: BiomarkerValueOrderByWithRelationInput | BiomarkerValueOrderByWithRelationInput[]
    cursor?: BiomarkerValueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BiomarkerValueScalarFieldEnum | BiomarkerValueScalarFieldEnum[]
  }

  /**
   * HealthReport without action
   */
  export type HealthReportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthReport
     */
    select?: HealthReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthReportInclude<ExtArgs> | null
  }


  /**
   * Model BiomarkerValue
   */

  export type AggregateBiomarkerValue = {
    _count: BiomarkerValueCountAggregateOutputType | null
    _avg: BiomarkerValueAvgAggregateOutputType | null
    _sum: BiomarkerValueSumAggregateOutputType | null
    _min: BiomarkerValueMinAggregateOutputType | null
    _max: BiomarkerValueMaxAggregateOutputType | null
  }

  export type BiomarkerValueAvgAggregateOutputType = {
    value: number | null
    referenceMin: number | null
    referenceMax: number | null
  }

  export type BiomarkerValueSumAggregateOutputType = {
    value: number | null
    referenceMin: number | null
    referenceMax: number | null
  }

  export type BiomarkerValueMinAggregateOutputType = {
    id: string | null
    healthReportId: string | null
    biomarkerId: string | null
    value: number | null
    unit: string | null
    referenceMin: number | null
    referenceMax: number | null
    isAbnormal: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BiomarkerValueMaxAggregateOutputType = {
    id: string | null
    healthReportId: string | null
    biomarkerId: string | null
    value: number | null
    unit: string | null
    referenceMin: number | null
    referenceMax: number | null
    isAbnormal: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BiomarkerValueCountAggregateOutputType = {
    id: number
    healthReportId: number
    biomarkerId: number
    value: number
    unit: number
    referenceMin: number
    referenceMax: number
    isAbnormal: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BiomarkerValueAvgAggregateInputType = {
    value?: true
    referenceMin?: true
    referenceMax?: true
  }

  export type BiomarkerValueSumAggregateInputType = {
    value?: true
    referenceMin?: true
    referenceMax?: true
  }

  export type BiomarkerValueMinAggregateInputType = {
    id?: true
    healthReportId?: true
    biomarkerId?: true
    value?: true
    unit?: true
    referenceMin?: true
    referenceMax?: true
    isAbnormal?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BiomarkerValueMaxAggregateInputType = {
    id?: true
    healthReportId?: true
    biomarkerId?: true
    value?: true
    unit?: true
    referenceMin?: true
    referenceMax?: true
    isAbnormal?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BiomarkerValueCountAggregateInputType = {
    id?: true
    healthReportId?: true
    biomarkerId?: true
    value?: true
    unit?: true
    referenceMin?: true
    referenceMax?: true
    isAbnormal?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BiomarkerValueAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BiomarkerValue to aggregate.
     */
    where?: BiomarkerValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BiomarkerValues to fetch.
     */
    orderBy?: BiomarkerValueOrderByWithRelationInput | BiomarkerValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BiomarkerValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BiomarkerValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BiomarkerValues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BiomarkerValues
    **/
    _count?: true | BiomarkerValueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BiomarkerValueAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BiomarkerValueSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BiomarkerValueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BiomarkerValueMaxAggregateInputType
  }

  export type GetBiomarkerValueAggregateType<T extends BiomarkerValueAggregateArgs> = {
        [P in keyof T & keyof AggregateBiomarkerValue]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBiomarkerValue[P]>
      : GetScalarType<T[P], AggregateBiomarkerValue[P]>
  }




  export type BiomarkerValueGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BiomarkerValueWhereInput
    orderBy?: BiomarkerValueOrderByWithAggregationInput | BiomarkerValueOrderByWithAggregationInput[]
    by: BiomarkerValueScalarFieldEnum[] | BiomarkerValueScalarFieldEnum
    having?: BiomarkerValueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BiomarkerValueCountAggregateInputType | true
    _avg?: BiomarkerValueAvgAggregateInputType
    _sum?: BiomarkerValueSumAggregateInputType
    _min?: BiomarkerValueMinAggregateInputType
    _max?: BiomarkerValueMaxAggregateInputType
  }

  export type BiomarkerValueGroupByOutputType = {
    id: string
    healthReportId: string
    biomarkerId: string
    value: number
    unit: string
    referenceMin: number | null
    referenceMax: number | null
    isAbnormal: boolean
    createdAt: Date
    updatedAt: Date
    _count: BiomarkerValueCountAggregateOutputType | null
    _avg: BiomarkerValueAvgAggregateOutputType | null
    _sum: BiomarkerValueSumAggregateOutputType | null
    _min: BiomarkerValueMinAggregateOutputType | null
    _max: BiomarkerValueMaxAggregateOutputType | null
  }

  type GetBiomarkerValueGroupByPayload<T extends BiomarkerValueGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BiomarkerValueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BiomarkerValueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BiomarkerValueGroupByOutputType[P]>
            : GetScalarType<T[P], BiomarkerValueGroupByOutputType[P]>
        }
      >
    >


  export type BiomarkerValueSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    healthReportId?: boolean
    biomarkerId?: boolean
    value?: boolean
    unit?: boolean
    referenceMin?: boolean
    referenceMax?: boolean
    isAbnormal?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    healthReport?: boolean | HealthReportDefaultArgs<ExtArgs>
    biomarker?: boolean | BiomarkerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["biomarkerValue"]>

  export type BiomarkerValueSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    healthReportId?: boolean
    biomarkerId?: boolean
    value?: boolean
    unit?: boolean
    referenceMin?: boolean
    referenceMax?: boolean
    isAbnormal?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    healthReport?: boolean | HealthReportDefaultArgs<ExtArgs>
    biomarker?: boolean | BiomarkerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["biomarkerValue"]>

  export type BiomarkerValueSelectScalar = {
    id?: boolean
    healthReportId?: boolean
    biomarkerId?: boolean
    value?: boolean
    unit?: boolean
    referenceMin?: boolean
    referenceMax?: boolean
    isAbnormal?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BiomarkerValueInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    healthReport?: boolean | HealthReportDefaultArgs<ExtArgs>
    biomarker?: boolean | BiomarkerDefaultArgs<ExtArgs>
  }
  export type BiomarkerValueIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    healthReport?: boolean | HealthReportDefaultArgs<ExtArgs>
    biomarker?: boolean | BiomarkerDefaultArgs<ExtArgs>
  }

  export type $BiomarkerValuePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BiomarkerValue"
    objects: {
      healthReport: Prisma.$HealthReportPayload<ExtArgs>
      biomarker: Prisma.$BiomarkerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      healthReportId: string
      biomarkerId: string
      value: number
      unit: string
      referenceMin: number | null
      referenceMax: number | null
      isAbnormal: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["biomarkerValue"]>
    composites: {}
  }

  type BiomarkerValueGetPayload<S extends boolean | null | undefined | BiomarkerValueDefaultArgs> = $Result.GetResult<Prisma.$BiomarkerValuePayload, S>

  type BiomarkerValueCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BiomarkerValueFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BiomarkerValueCountAggregateInputType | true
    }

  export interface BiomarkerValueDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BiomarkerValue'], meta: { name: 'BiomarkerValue' } }
    /**
     * Find zero or one BiomarkerValue that matches the filter.
     * @param {BiomarkerValueFindUniqueArgs} args - Arguments to find a BiomarkerValue
     * @example
     * // Get one BiomarkerValue
     * const biomarkerValue = await prisma.biomarkerValue.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BiomarkerValueFindUniqueArgs>(args: SelectSubset<T, BiomarkerValueFindUniqueArgs<ExtArgs>>): Prisma__BiomarkerValueClient<$Result.GetResult<Prisma.$BiomarkerValuePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one BiomarkerValue that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BiomarkerValueFindUniqueOrThrowArgs} args - Arguments to find a BiomarkerValue
     * @example
     * // Get one BiomarkerValue
     * const biomarkerValue = await prisma.biomarkerValue.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BiomarkerValueFindUniqueOrThrowArgs>(args: SelectSubset<T, BiomarkerValueFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BiomarkerValueClient<$Result.GetResult<Prisma.$BiomarkerValuePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first BiomarkerValue that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BiomarkerValueFindFirstArgs} args - Arguments to find a BiomarkerValue
     * @example
     * // Get one BiomarkerValue
     * const biomarkerValue = await prisma.biomarkerValue.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BiomarkerValueFindFirstArgs>(args?: SelectSubset<T, BiomarkerValueFindFirstArgs<ExtArgs>>): Prisma__BiomarkerValueClient<$Result.GetResult<Prisma.$BiomarkerValuePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first BiomarkerValue that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BiomarkerValueFindFirstOrThrowArgs} args - Arguments to find a BiomarkerValue
     * @example
     * // Get one BiomarkerValue
     * const biomarkerValue = await prisma.biomarkerValue.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BiomarkerValueFindFirstOrThrowArgs>(args?: SelectSubset<T, BiomarkerValueFindFirstOrThrowArgs<ExtArgs>>): Prisma__BiomarkerValueClient<$Result.GetResult<Prisma.$BiomarkerValuePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more BiomarkerValues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BiomarkerValueFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BiomarkerValues
     * const biomarkerValues = await prisma.biomarkerValue.findMany()
     * 
     * // Get first 10 BiomarkerValues
     * const biomarkerValues = await prisma.biomarkerValue.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const biomarkerValueWithIdOnly = await prisma.biomarkerValue.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BiomarkerValueFindManyArgs>(args?: SelectSubset<T, BiomarkerValueFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BiomarkerValuePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a BiomarkerValue.
     * @param {BiomarkerValueCreateArgs} args - Arguments to create a BiomarkerValue.
     * @example
     * // Create one BiomarkerValue
     * const BiomarkerValue = await prisma.biomarkerValue.create({
     *   data: {
     *     // ... data to create a BiomarkerValue
     *   }
     * })
     * 
     */
    create<T extends BiomarkerValueCreateArgs>(args: SelectSubset<T, BiomarkerValueCreateArgs<ExtArgs>>): Prisma__BiomarkerValueClient<$Result.GetResult<Prisma.$BiomarkerValuePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many BiomarkerValues.
     * @param {BiomarkerValueCreateManyArgs} args - Arguments to create many BiomarkerValues.
     * @example
     * // Create many BiomarkerValues
     * const biomarkerValue = await prisma.biomarkerValue.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BiomarkerValueCreateManyArgs>(args?: SelectSubset<T, BiomarkerValueCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BiomarkerValues and returns the data saved in the database.
     * @param {BiomarkerValueCreateManyAndReturnArgs} args - Arguments to create many BiomarkerValues.
     * @example
     * // Create many BiomarkerValues
     * const biomarkerValue = await prisma.biomarkerValue.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BiomarkerValues and only return the `id`
     * const biomarkerValueWithIdOnly = await prisma.biomarkerValue.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BiomarkerValueCreateManyAndReturnArgs>(args?: SelectSubset<T, BiomarkerValueCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BiomarkerValuePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a BiomarkerValue.
     * @param {BiomarkerValueDeleteArgs} args - Arguments to delete one BiomarkerValue.
     * @example
     * // Delete one BiomarkerValue
     * const BiomarkerValue = await prisma.biomarkerValue.delete({
     *   where: {
     *     // ... filter to delete one BiomarkerValue
     *   }
     * })
     * 
     */
    delete<T extends BiomarkerValueDeleteArgs>(args: SelectSubset<T, BiomarkerValueDeleteArgs<ExtArgs>>): Prisma__BiomarkerValueClient<$Result.GetResult<Prisma.$BiomarkerValuePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one BiomarkerValue.
     * @param {BiomarkerValueUpdateArgs} args - Arguments to update one BiomarkerValue.
     * @example
     * // Update one BiomarkerValue
     * const biomarkerValue = await prisma.biomarkerValue.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BiomarkerValueUpdateArgs>(args: SelectSubset<T, BiomarkerValueUpdateArgs<ExtArgs>>): Prisma__BiomarkerValueClient<$Result.GetResult<Prisma.$BiomarkerValuePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more BiomarkerValues.
     * @param {BiomarkerValueDeleteManyArgs} args - Arguments to filter BiomarkerValues to delete.
     * @example
     * // Delete a few BiomarkerValues
     * const { count } = await prisma.biomarkerValue.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BiomarkerValueDeleteManyArgs>(args?: SelectSubset<T, BiomarkerValueDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BiomarkerValues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BiomarkerValueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BiomarkerValues
     * const biomarkerValue = await prisma.biomarkerValue.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BiomarkerValueUpdateManyArgs>(args: SelectSubset<T, BiomarkerValueUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BiomarkerValue.
     * @param {BiomarkerValueUpsertArgs} args - Arguments to update or create a BiomarkerValue.
     * @example
     * // Update or create a BiomarkerValue
     * const biomarkerValue = await prisma.biomarkerValue.upsert({
     *   create: {
     *     // ... data to create a BiomarkerValue
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BiomarkerValue we want to update
     *   }
     * })
     */
    upsert<T extends BiomarkerValueUpsertArgs>(args: SelectSubset<T, BiomarkerValueUpsertArgs<ExtArgs>>): Prisma__BiomarkerValueClient<$Result.GetResult<Prisma.$BiomarkerValuePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of BiomarkerValues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BiomarkerValueCountArgs} args - Arguments to filter BiomarkerValues to count.
     * @example
     * // Count the number of BiomarkerValues
     * const count = await prisma.biomarkerValue.count({
     *   where: {
     *     // ... the filter for the BiomarkerValues we want to count
     *   }
     * })
    **/
    count<T extends BiomarkerValueCountArgs>(
      args?: Subset<T, BiomarkerValueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BiomarkerValueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BiomarkerValue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BiomarkerValueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BiomarkerValueAggregateArgs>(args: Subset<T, BiomarkerValueAggregateArgs>): Prisma.PrismaPromise<GetBiomarkerValueAggregateType<T>>

    /**
     * Group by BiomarkerValue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BiomarkerValueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BiomarkerValueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BiomarkerValueGroupByArgs['orderBy'] }
        : { orderBy?: BiomarkerValueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BiomarkerValueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBiomarkerValueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BiomarkerValue model
   */
  readonly fields: BiomarkerValueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BiomarkerValue.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BiomarkerValueClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    healthReport<T extends HealthReportDefaultArgs<ExtArgs> = {}>(args?: Subset<T, HealthReportDefaultArgs<ExtArgs>>): Prisma__HealthReportClient<$Result.GetResult<Prisma.$HealthReportPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    biomarker<T extends BiomarkerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BiomarkerDefaultArgs<ExtArgs>>): Prisma__BiomarkerClient<$Result.GetResult<Prisma.$BiomarkerPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BiomarkerValue model
   */ 
  interface BiomarkerValueFieldRefs {
    readonly id: FieldRef<"BiomarkerValue", 'String'>
    readonly healthReportId: FieldRef<"BiomarkerValue", 'String'>
    readonly biomarkerId: FieldRef<"BiomarkerValue", 'String'>
    readonly value: FieldRef<"BiomarkerValue", 'Float'>
    readonly unit: FieldRef<"BiomarkerValue", 'String'>
    readonly referenceMin: FieldRef<"BiomarkerValue", 'Float'>
    readonly referenceMax: FieldRef<"BiomarkerValue", 'Float'>
    readonly isAbnormal: FieldRef<"BiomarkerValue", 'Boolean'>
    readonly createdAt: FieldRef<"BiomarkerValue", 'DateTime'>
    readonly updatedAt: FieldRef<"BiomarkerValue", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BiomarkerValue findUnique
   */
  export type BiomarkerValueFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BiomarkerValue
     */
    select?: BiomarkerValueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiomarkerValueInclude<ExtArgs> | null
    /**
     * Filter, which BiomarkerValue to fetch.
     */
    where: BiomarkerValueWhereUniqueInput
  }

  /**
   * BiomarkerValue findUniqueOrThrow
   */
  export type BiomarkerValueFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BiomarkerValue
     */
    select?: BiomarkerValueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiomarkerValueInclude<ExtArgs> | null
    /**
     * Filter, which BiomarkerValue to fetch.
     */
    where: BiomarkerValueWhereUniqueInput
  }

  /**
   * BiomarkerValue findFirst
   */
  export type BiomarkerValueFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BiomarkerValue
     */
    select?: BiomarkerValueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiomarkerValueInclude<ExtArgs> | null
    /**
     * Filter, which BiomarkerValue to fetch.
     */
    where?: BiomarkerValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BiomarkerValues to fetch.
     */
    orderBy?: BiomarkerValueOrderByWithRelationInput | BiomarkerValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BiomarkerValues.
     */
    cursor?: BiomarkerValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BiomarkerValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BiomarkerValues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BiomarkerValues.
     */
    distinct?: BiomarkerValueScalarFieldEnum | BiomarkerValueScalarFieldEnum[]
  }

  /**
   * BiomarkerValue findFirstOrThrow
   */
  export type BiomarkerValueFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BiomarkerValue
     */
    select?: BiomarkerValueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiomarkerValueInclude<ExtArgs> | null
    /**
     * Filter, which BiomarkerValue to fetch.
     */
    where?: BiomarkerValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BiomarkerValues to fetch.
     */
    orderBy?: BiomarkerValueOrderByWithRelationInput | BiomarkerValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BiomarkerValues.
     */
    cursor?: BiomarkerValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BiomarkerValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BiomarkerValues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BiomarkerValues.
     */
    distinct?: BiomarkerValueScalarFieldEnum | BiomarkerValueScalarFieldEnum[]
  }

  /**
   * BiomarkerValue findMany
   */
  export type BiomarkerValueFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BiomarkerValue
     */
    select?: BiomarkerValueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiomarkerValueInclude<ExtArgs> | null
    /**
     * Filter, which BiomarkerValues to fetch.
     */
    where?: BiomarkerValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BiomarkerValues to fetch.
     */
    orderBy?: BiomarkerValueOrderByWithRelationInput | BiomarkerValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BiomarkerValues.
     */
    cursor?: BiomarkerValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BiomarkerValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BiomarkerValues.
     */
    skip?: number
    distinct?: BiomarkerValueScalarFieldEnum | BiomarkerValueScalarFieldEnum[]
  }

  /**
   * BiomarkerValue create
   */
  export type BiomarkerValueCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BiomarkerValue
     */
    select?: BiomarkerValueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiomarkerValueInclude<ExtArgs> | null
    /**
     * The data needed to create a BiomarkerValue.
     */
    data: XOR<BiomarkerValueCreateInput, BiomarkerValueUncheckedCreateInput>
  }

  /**
   * BiomarkerValue createMany
   */
  export type BiomarkerValueCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BiomarkerValues.
     */
    data: BiomarkerValueCreateManyInput | BiomarkerValueCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BiomarkerValue createManyAndReturn
   */
  export type BiomarkerValueCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BiomarkerValue
     */
    select?: BiomarkerValueSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many BiomarkerValues.
     */
    data: BiomarkerValueCreateManyInput | BiomarkerValueCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiomarkerValueIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BiomarkerValue update
   */
  export type BiomarkerValueUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BiomarkerValue
     */
    select?: BiomarkerValueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiomarkerValueInclude<ExtArgs> | null
    /**
     * The data needed to update a BiomarkerValue.
     */
    data: XOR<BiomarkerValueUpdateInput, BiomarkerValueUncheckedUpdateInput>
    /**
     * Choose, which BiomarkerValue to update.
     */
    where: BiomarkerValueWhereUniqueInput
  }

  /**
   * BiomarkerValue updateMany
   */
  export type BiomarkerValueUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BiomarkerValues.
     */
    data: XOR<BiomarkerValueUpdateManyMutationInput, BiomarkerValueUncheckedUpdateManyInput>
    /**
     * Filter which BiomarkerValues to update
     */
    where?: BiomarkerValueWhereInput
  }

  /**
   * BiomarkerValue upsert
   */
  export type BiomarkerValueUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BiomarkerValue
     */
    select?: BiomarkerValueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiomarkerValueInclude<ExtArgs> | null
    /**
     * The filter to search for the BiomarkerValue to update in case it exists.
     */
    where: BiomarkerValueWhereUniqueInput
    /**
     * In case the BiomarkerValue found by the `where` argument doesn't exist, create a new BiomarkerValue with this data.
     */
    create: XOR<BiomarkerValueCreateInput, BiomarkerValueUncheckedCreateInput>
    /**
     * In case the BiomarkerValue was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BiomarkerValueUpdateInput, BiomarkerValueUncheckedUpdateInput>
  }

  /**
   * BiomarkerValue delete
   */
  export type BiomarkerValueDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BiomarkerValue
     */
    select?: BiomarkerValueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiomarkerValueInclude<ExtArgs> | null
    /**
     * Filter which BiomarkerValue to delete.
     */
    where: BiomarkerValueWhereUniqueInput
  }

  /**
   * BiomarkerValue deleteMany
   */
  export type BiomarkerValueDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BiomarkerValues to delete
     */
    where?: BiomarkerValueWhereInput
  }

  /**
   * BiomarkerValue without action
   */
  export type BiomarkerValueDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BiomarkerValue
     */
    select?: BiomarkerValueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiomarkerValueInclude<ExtArgs> | null
  }


  /**
   * Model Biomarker
   */

  export type AggregateBiomarker = {
    _count: BiomarkerCountAggregateOutputType | null
    _avg: BiomarkerAvgAggregateOutputType | null
    _sum: BiomarkerSumAggregateOutputType | null
    _min: BiomarkerMinAggregateOutputType | null
    _max: BiomarkerMaxAggregateOutputType | null
  }

  export type BiomarkerAvgAggregateOutputType = {
    defaultMinRange: number | null
    defaultMaxRange: number | null
  }

  export type BiomarkerSumAggregateOutputType = {
    defaultMinRange: number | null
    defaultMaxRange: number | null
  }

  export type BiomarkerMinAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    description: string | null
    category: string | null
    unit: string | null
    defaultMinRange: number | null
    defaultMaxRange: number | null
  }

  export type BiomarkerMaxAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    description: string | null
    category: string | null
    unit: string | null
    defaultMinRange: number | null
    defaultMaxRange: number | null
  }

  export type BiomarkerCountAggregateOutputType = {
    id: number
    code: number
    name: number
    description: number
    category: number
    unit: number
    defaultMinRange: number
    defaultMaxRange: number
    _all: number
  }


  export type BiomarkerAvgAggregateInputType = {
    defaultMinRange?: true
    defaultMaxRange?: true
  }

  export type BiomarkerSumAggregateInputType = {
    defaultMinRange?: true
    defaultMaxRange?: true
  }

  export type BiomarkerMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    category?: true
    unit?: true
    defaultMinRange?: true
    defaultMaxRange?: true
  }

  export type BiomarkerMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    category?: true
    unit?: true
    defaultMinRange?: true
    defaultMaxRange?: true
  }

  export type BiomarkerCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    category?: true
    unit?: true
    defaultMinRange?: true
    defaultMaxRange?: true
    _all?: true
  }

  export type BiomarkerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Biomarker to aggregate.
     */
    where?: BiomarkerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Biomarkers to fetch.
     */
    orderBy?: BiomarkerOrderByWithRelationInput | BiomarkerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BiomarkerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Biomarkers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Biomarkers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Biomarkers
    **/
    _count?: true | BiomarkerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BiomarkerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BiomarkerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BiomarkerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BiomarkerMaxAggregateInputType
  }

  export type GetBiomarkerAggregateType<T extends BiomarkerAggregateArgs> = {
        [P in keyof T & keyof AggregateBiomarker]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBiomarker[P]>
      : GetScalarType<T[P], AggregateBiomarker[P]>
  }




  export type BiomarkerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BiomarkerWhereInput
    orderBy?: BiomarkerOrderByWithAggregationInput | BiomarkerOrderByWithAggregationInput[]
    by: BiomarkerScalarFieldEnum[] | BiomarkerScalarFieldEnum
    having?: BiomarkerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BiomarkerCountAggregateInputType | true
    _avg?: BiomarkerAvgAggregateInputType
    _sum?: BiomarkerSumAggregateInputType
    _min?: BiomarkerMinAggregateInputType
    _max?: BiomarkerMaxAggregateInputType
  }

  export type BiomarkerGroupByOutputType = {
    id: string
    code: string
    name: string
    description: string | null
    category: string
    unit: string
    defaultMinRange: number | null
    defaultMaxRange: number | null
    _count: BiomarkerCountAggregateOutputType | null
    _avg: BiomarkerAvgAggregateOutputType | null
    _sum: BiomarkerSumAggregateOutputType | null
    _min: BiomarkerMinAggregateOutputType | null
    _max: BiomarkerMaxAggregateOutputType | null
  }

  type GetBiomarkerGroupByPayload<T extends BiomarkerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BiomarkerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BiomarkerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BiomarkerGroupByOutputType[P]>
            : GetScalarType<T[P], BiomarkerGroupByOutputType[P]>
        }
      >
    >


  export type BiomarkerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    unit?: boolean
    defaultMinRange?: boolean
    defaultMaxRange?: boolean
    values?: boolean | Biomarker$valuesArgs<ExtArgs>
    correlations?: boolean | Biomarker$correlationsArgs<ExtArgs>
    _count?: boolean | BiomarkerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["biomarker"]>

  export type BiomarkerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    unit?: boolean
    defaultMinRange?: boolean
    defaultMaxRange?: boolean
  }, ExtArgs["result"]["biomarker"]>

  export type BiomarkerSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    unit?: boolean
    defaultMinRange?: boolean
    defaultMaxRange?: boolean
  }

  export type BiomarkerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    values?: boolean | Biomarker$valuesArgs<ExtArgs>
    correlations?: boolean | Biomarker$correlationsArgs<ExtArgs>
    _count?: boolean | BiomarkerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BiomarkerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $BiomarkerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Biomarker"
    objects: {
      values: Prisma.$BiomarkerValuePayload<ExtArgs>[]
      correlations: Prisma.$CorrelationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      name: string
      description: string | null
      category: string
      unit: string
      defaultMinRange: number | null
      defaultMaxRange: number | null
    }, ExtArgs["result"]["biomarker"]>
    composites: {}
  }

  type BiomarkerGetPayload<S extends boolean | null | undefined | BiomarkerDefaultArgs> = $Result.GetResult<Prisma.$BiomarkerPayload, S>

  type BiomarkerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BiomarkerFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BiomarkerCountAggregateInputType | true
    }

  export interface BiomarkerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Biomarker'], meta: { name: 'Biomarker' } }
    /**
     * Find zero or one Biomarker that matches the filter.
     * @param {BiomarkerFindUniqueArgs} args - Arguments to find a Biomarker
     * @example
     * // Get one Biomarker
     * const biomarker = await prisma.biomarker.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BiomarkerFindUniqueArgs>(args: SelectSubset<T, BiomarkerFindUniqueArgs<ExtArgs>>): Prisma__BiomarkerClient<$Result.GetResult<Prisma.$BiomarkerPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Biomarker that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BiomarkerFindUniqueOrThrowArgs} args - Arguments to find a Biomarker
     * @example
     * // Get one Biomarker
     * const biomarker = await prisma.biomarker.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BiomarkerFindUniqueOrThrowArgs>(args: SelectSubset<T, BiomarkerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BiomarkerClient<$Result.GetResult<Prisma.$BiomarkerPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Biomarker that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BiomarkerFindFirstArgs} args - Arguments to find a Biomarker
     * @example
     * // Get one Biomarker
     * const biomarker = await prisma.biomarker.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BiomarkerFindFirstArgs>(args?: SelectSubset<T, BiomarkerFindFirstArgs<ExtArgs>>): Prisma__BiomarkerClient<$Result.GetResult<Prisma.$BiomarkerPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Biomarker that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BiomarkerFindFirstOrThrowArgs} args - Arguments to find a Biomarker
     * @example
     * // Get one Biomarker
     * const biomarker = await prisma.biomarker.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BiomarkerFindFirstOrThrowArgs>(args?: SelectSubset<T, BiomarkerFindFirstOrThrowArgs<ExtArgs>>): Prisma__BiomarkerClient<$Result.GetResult<Prisma.$BiomarkerPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Biomarkers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BiomarkerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Biomarkers
     * const biomarkers = await prisma.biomarker.findMany()
     * 
     * // Get first 10 Biomarkers
     * const biomarkers = await prisma.biomarker.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const biomarkerWithIdOnly = await prisma.biomarker.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BiomarkerFindManyArgs>(args?: SelectSubset<T, BiomarkerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BiomarkerPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Biomarker.
     * @param {BiomarkerCreateArgs} args - Arguments to create a Biomarker.
     * @example
     * // Create one Biomarker
     * const Biomarker = await prisma.biomarker.create({
     *   data: {
     *     // ... data to create a Biomarker
     *   }
     * })
     * 
     */
    create<T extends BiomarkerCreateArgs>(args: SelectSubset<T, BiomarkerCreateArgs<ExtArgs>>): Prisma__BiomarkerClient<$Result.GetResult<Prisma.$BiomarkerPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Biomarkers.
     * @param {BiomarkerCreateManyArgs} args - Arguments to create many Biomarkers.
     * @example
     * // Create many Biomarkers
     * const biomarker = await prisma.biomarker.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BiomarkerCreateManyArgs>(args?: SelectSubset<T, BiomarkerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Biomarkers and returns the data saved in the database.
     * @param {BiomarkerCreateManyAndReturnArgs} args - Arguments to create many Biomarkers.
     * @example
     * // Create many Biomarkers
     * const biomarker = await prisma.biomarker.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Biomarkers and only return the `id`
     * const biomarkerWithIdOnly = await prisma.biomarker.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BiomarkerCreateManyAndReturnArgs>(args?: SelectSubset<T, BiomarkerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BiomarkerPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Biomarker.
     * @param {BiomarkerDeleteArgs} args - Arguments to delete one Biomarker.
     * @example
     * // Delete one Biomarker
     * const Biomarker = await prisma.biomarker.delete({
     *   where: {
     *     // ... filter to delete one Biomarker
     *   }
     * })
     * 
     */
    delete<T extends BiomarkerDeleteArgs>(args: SelectSubset<T, BiomarkerDeleteArgs<ExtArgs>>): Prisma__BiomarkerClient<$Result.GetResult<Prisma.$BiomarkerPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Biomarker.
     * @param {BiomarkerUpdateArgs} args - Arguments to update one Biomarker.
     * @example
     * // Update one Biomarker
     * const biomarker = await prisma.biomarker.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BiomarkerUpdateArgs>(args: SelectSubset<T, BiomarkerUpdateArgs<ExtArgs>>): Prisma__BiomarkerClient<$Result.GetResult<Prisma.$BiomarkerPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Biomarkers.
     * @param {BiomarkerDeleteManyArgs} args - Arguments to filter Biomarkers to delete.
     * @example
     * // Delete a few Biomarkers
     * const { count } = await prisma.biomarker.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BiomarkerDeleteManyArgs>(args?: SelectSubset<T, BiomarkerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Biomarkers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BiomarkerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Biomarkers
     * const biomarker = await prisma.biomarker.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BiomarkerUpdateManyArgs>(args: SelectSubset<T, BiomarkerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Biomarker.
     * @param {BiomarkerUpsertArgs} args - Arguments to update or create a Biomarker.
     * @example
     * // Update or create a Biomarker
     * const biomarker = await prisma.biomarker.upsert({
     *   create: {
     *     // ... data to create a Biomarker
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Biomarker we want to update
     *   }
     * })
     */
    upsert<T extends BiomarkerUpsertArgs>(args: SelectSubset<T, BiomarkerUpsertArgs<ExtArgs>>): Prisma__BiomarkerClient<$Result.GetResult<Prisma.$BiomarkerPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Biomarkers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BiomarkerCountArgs} args - Arguments to filter Biomarkers to count.
     * @example
     * // Count the number of Biomarkers
     * const count = await prisma.biomarker.count({
     *   where: {
     *     // ... the filter for the Biomarkers we want to count
     *   }
     * })
    **/
    count<T extends BiomarkerCountArgs>(
      args?: Subset<T, BiomarkerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BiomarkerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Biomarker.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BiomarkerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BiomarkerAggregateArgs>(args: Subset<T, BiomarkerAggregateArgs>): Prisma.PrismaPromise<GetBiomarkerAggregateType<T>>

    /**
     * Group by Biomarker.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BiomarkerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BiomarkerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BiomarkerGroupByArgs['orderBy'] }
        : { orderBy?: BiomarkerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BiomarkerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBiomarkerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Biomarker model
   */
  readonly fields: BiomarkerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Biomarker.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BiomarkerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    values<T extends Biomarker$valuesArgs<ExtArgs> = {}>(args?: Subset<T, Biomarker$valuesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BiomarkerValuePayload<ExtArgs>, T, "findMany"> | Null>
    correlations<T extends Biomarker$correlationsArgs<ExtArgs> = {}>(args?: Subset<T, Biomarker$correlationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CorrelationPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Biomarker model
   */ 
  interface BiomarkerFieldRefs {
    readonly id: FieldRef<"Biomarker", 'String'>
    readonly code: FieldRef<"Biomarker", 'String'>
    readonly name: FieldRef<"Biomarker", 'String'>
    readonly description: FieldRef<"Biomarker", 'String'>
    readonly category: FieldRef<"Biomarker", 'String'>
    readonly unit: FieldRef<"Biomarker", 'String'>
    readonly defaultMinRange: FieldRef<"Biomarker", 'Float'>
    readonly defaultMaxRange: FieldRef<"Biomarker", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * Biomarker findUnique
   */
  export type BiomarkerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Biomarker
     */
    select?: BiomarkerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiomarkerInclude<ExtArgs> | null
    /**
     * Filter, which Biomarker to fetch.
     */
    where: BiomarkerWhereUniqueInput
  }

  /**
   * Biomarker findUniqueOrThrow
   */
  export type BiomarkerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Biomarker
     */
    select?: BiomarkerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiomarkerInclude<ExtArgs> | null
    /**
     * Filter, which Biomarker to fetch.
     */
    where: BiomarkerWhereUniqueInput
  }

  /**
   * Biomarker findFirst
   */
  export type BiomarkerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Biomarker
     */
    select?: BiomarkerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiomarkerInclude<ExtArgs> | null
    /**
     * Filter, which Biomarker to fetch.
     */
    where?: BiomarkerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Biomarkers to fetch.
     */
    orderBy?: BiomarkerOrderByWithRelationInput | BiomarkerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Biomarkers.
     */
    cursor?: BiomarkerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Biomarkers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Biomarkers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Biomarkers.
     */
    distinct?: BiomarkerScalarFieldEnum | BiomarkerScalarFieldEnum[]
  }

  /**
   * Biomarker findFirstOrThrow
   */
  export type BiomarkerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Biomarker
     */
    select?: BiomarkerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiomarkerInclude<ExtArgs> | null
    /**
     * Filter, which Biomarker to fetch.
     */
    where?: BiomarkerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Biomarkers to fetch.
     */
    orderBy?: BiomarkerOrderByWithRelationInput | BiomarkerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Biomarkers.
     */
    cursor?: BiomarkerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Biomarkers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Biomarkers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Biomarkers.
     */
    distinct?: BiomarkerScalarFieldEnum | BiomarkerScalarFieldEnum[]
  }

  /**
   * Biomarker findMany
   */
  export type BiomarkerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Biomarker
     */
    select?: BiomarkerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiomarkerInclude<ExtArgs> | null
    /**
     * Filter, which Biomarkers to fetch.
     */
    where?: BiomarkerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Biomarkers to fetch.
     */
    orderBy?: BiomarkerOrderByWithRelationInput | BiomarkerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Biomarkers.
     */
    cursor?: BiomarkerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Biomarkers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Biomarkers.
     */
    skip?: number
    distinct?: BiomarkerScalarFieldEnum | BiomarkerScalarFieldEnum[]
  }

  /**
   * Biomarker create
   */
  export type BiomarkerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Biomarker
     */
    select?: BiomarkerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiomarkerInclude<ExtArgs> | null
    /**
     * The data needed to create a Biomarker.
     */
    data: XOR<BiomarkerCreateInput, BiomarkerUncheckedCreateInput>
  }

  /**
   * Biomarker createMany
   */
  export type BiomarkerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Biomarkers.
     */
    data: BiomarkerCreateManyInput | BiomarkerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Biomarker createManyAndReturn
   */
  export type BiomarkerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Biomarker
     */
    select?: BiomarkerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Biomarkers.
     */
    data: BiomarkerCreateManyInput | BiomarkerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Biomarker update
   */
  export type BiomarkerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Biomarker
     */
    select?: BiomarkerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiomarkerInclude<ExtArgs> | null
    /**
     * The data needed to update a Biomarker.
     */
    data: XOR<BiomarkerUpdateInput, BiomarkerUncheckedUpdateInput>
    /**
     * Choose, which Biomarker to update.
     */
    where: BiomarkerWhereUniqueInput
  }

  /**
   * Biomarker updateMany
   */
  export type BiomarkerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Biomarkers.
     */
    data: XOR<BiomarkerUpdateManyMutationInput, BiomarkerUncheckedUpdateManyInput>
    /**
     * Filter which Biomarkers to update
     */
    where?: BiomarkerWhereInput
  }

  /**
   * Biomarker upsert
   */
  export type BiomarkerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Biomarker
     */
    select?: BiomarkerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiomarkerInclude<ExtArgs> | null
    /**
     * The filter to search for the Biomarker to update in case it exists.
     */
    where: BiomarkerWhereUniqueInput
    /**
     * In case the Biomarker found by the `where` argument doesn't exist, create a new Biomarker with this data.
     */
    create: XOR<BiomarkerCreateInput, BiomarkerUncheckedCreateInput>
    /**
     * In case the Biomarker was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BiomarkerUpdateInput, BiomarkerUncheckedUpdateInput>
  }

  /**
   * Biomarker delete
   */
  export type BiomarkerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Biomarker
     */
    select?: BiomarkerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiomarkerInclude<ExtArgs> | null
    /**
     * Filter which Biomarker to delete.
     */
    where: BiomarkerWhereUniqueInput
  }

  /**
   * Biomarker deleteMany
   */
  export type BiomarkerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Biomarkers to delete
     */
    where?: BiomarkerWhereInput
  }

  /**
   * Biomarker.values
   */
  export type Biomarker$valuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BiomarkerValue
     */
    select?: BiomarkerValueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiomarkerValueInclude<ExtArgs> | null
    where?: BiomarkerValueWhereInput
    orderBy?: BiomarkerValueOrderByWithRelationInput | BiomarkerValueOrderByWithRelationInput[]
    cursor?: BiomarkerValueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BiomarkerValueScalarFieldEnum | BiomarkerValueScalarFieldEnum[]
  }

  /**
   * Biomarker.correlations
   */
  export type Biomarker$correlationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Correlation
     */
    select?: CorrelationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CorrelationInclude<ExtArgs> | null
    where?: CorrelationWhereInput
    orderBy?: CorrelationOrderByWithRelationInput | CorrelationOrderByWithRelationInput[]
    cursor?: CorrelationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CorrelationScalarFieldEnum | CorrelationScalarFieldEnum[]
  }

  /**
   * Biomarker without action
   */
  export type BiomarkerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Biomarker
     */
    select?: BiomarkerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiomarkerInclude<ExtArgs> | null
  }


  /**
   * Model Symptom
   */

  export type AggregateSymptom = {
    _count: SymptomCountAggregateOutputType | null
    _avg: SymptomAvgAggregateOutputType | null
    _sum: SymptomSumAggregateOutputType | null
    _min: SymptomMinAggregateOutputType | null
    _max: SymptomMaxAggregateOutputType | null
  }

  export type SymptomAvgAggregateOutputType = {
    severity: number | null
  }

  export type SymptomSumAggregateOutputType = {
    severity: number | null
  }

  export type SymptomMinAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    severity: number | null
    startDate: Date | null
    endDate: Date | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SymptomMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    severity: number | null
    startDate: Date | null
    endDate: Date | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SymptomCountAggregateOutputType = {
    id: number
    userId: number
    name: number
    severity: number
    startDate: number
    endDate: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SymptomAvgAggregateInputType = {
    severity?: true
  }

  export type SymptomSumAggregateInputType = {
    severity?: true
  }

  export type SymptomMinAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    severity?: true
    startDate?: true
    endDate?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SymptomMaxAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    severity?: true
    startDate?: true
    endDate?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SymptomCountAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    severity?: true
    startDate?: true
    endDate?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SymptomAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Symptom to aggregate.
     */
    where?: SymptomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Symptoms to fetch.
     */
    orderBy?: SymptomOrderByWithRelationInput | SymptomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SymptomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Symptoms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Symptoms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Symptoms
    **/
    _count?: true | SymptomCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SymptomAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SymptomSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SymptomMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SymptomMaxAggregateInputType
  }

  export type GetSymptomAggregateType<T extends SymptomAggregateArgs> = {
        [P in keyof T & keyof AggregateSymptom]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSymptom[P]>
      : GetScalarType<T[P], AggregateSymptom[P]>
  }




  export type SymptomGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SymptomWhereInput
    orderBy?: SymptomOrderByWithAggregationInput | SymptomOrderByWithAggregationInput[]
    by: SymptomScalarFieldEnum[] | SymptomScalarFieldEnum
    having?: SymptomScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SymptomCountAggregateInputType | true
    _avg?: SymptomAvgAggregateInputType
    _sum?: SymptomSumAggregateInputType
    _min?: SymptomMinAggregateInputType
    _max?: SymptomMaxAggregateInputType
  }

  export type SymptomGroupByOutputType = {
    id: string
    userId: string
    name: string
    severity: number
    startDate: Date
    endDate: Date | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: SymptomCountAggregateOutputType | null
    _avg: SymptomAvgAggregateOutputType | null
    _sum: SymptomSumAggregateOutputType | null
    _min: SymptomMinAggregateOutputType | null
    _max: SymptomMaxAggregateOutputType | null
  }

  type GetSymptomGroupByPayload<T extends SymptomGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SymptomGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SymptomGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SymptomGroupByOutputType[P]>
            : GetScalarType<T[P], SymptomGroupByOutputType[P]>
        }
      >
    >


  export type SymptomSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    severity?: boolean
    startDate?: boolean
    endDate?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    correlations?: boolean | Symptom$correlationsArgs<ExtArgs>
    _count?: boolean | SymptomCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["symptom"]>

  export type SymptomSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    severity?: boolean
    startDate?: boolean
    endDate?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["symptom"]>

  export type SymptomSelectScalar = {
    id?: boolean
    userId?: boolean
    name?: boolean
    severity?: boolean
    startDate?: boolean
    endDate?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SymptomInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    correlations?: boolean | Symptom$correlationsArgs<ExtArgs>
    _count?: boolean | SymptomCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SymptomIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SymptomPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Symptom"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      correlations: Prisma.$CorrelationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      name: string
      severity: number
      startDate: Date
      endDate: Date | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["symptom"]>
    composites: {}
  }

  type SymptomGetPayload<S extends boolean | null | undefined | SymptomDefaultArgs> = $Result.GetResult<Prisma.$SymptomPayload, S>

  type SymptomCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SymptomFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SymptomCountAggregateInputType | true
    }

  export interface SymptomDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Symptom'], meta: { name: 'Symptom' } }
    /**
     * Find zero or one Symptom that matches the filter.
     * @param {SymptomFindUniqueArgs} args - Arguments to find a Symptom
     * @example
     * // Get one Symptom
     * const symptom = await prisma.symptom.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SymptomFindUniqueArgs>(args: SelectSubset<T, SymptomFindUniqueArgs<ExtArgs>>): Prisma__SymptomClient<$Result.GetResult<Prisma.$SymptomPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Symptom that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SymptomFindUniqueOrThrowArgs} args - Arguments to find a Symptom
     * @example
     * // Get one Symptom
     * const symptom = await prisma.symptom.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SymptomFindUniqueOrThrowArgs>(args: SelectSubset<T, SymptomFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SymptomClient<$Result.GetResult<Prisma.$SymptomPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Symptom that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SymptomFindFirstArgs} args - Arguments to find a Symptom
     * @example
     * // Get one Symptom
     * const symptom = await prisma.symptom.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SymptomFindFirstArgs>(args?: SelectSubset<T, SymptomFindFirstArgs<ExtArgs>>): Prisma__SymptomClient<$Result.GetResult<Prisma.$SymptomPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Symptom that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SymptomFindFirstOrThrowArgs} args - Arguments to find a Symptom
     * @example
     * // Get one Symptom
     * const symptom = await prisma.symptom.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SymptomFindFirstOrThrowArgs>(args?: SelectSubset<T, SymptomFindFirstOrThrowArgs<ExtArgs>>): Prisma__SymptomClient<$Result.GetResult<Prisma.$SymptomPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Symptoms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SymptomFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Symptoms
     * const symptoms = await prisma.symptom.findMany()
     * 
     * // Get first 10 Symptoms
     * const symptoms = await prisma.symptom.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const symptomWithIdOnly = await prisma.symptom.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SymptomFindManyArgs>(args?: SelectSubset<T, SymptomFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SymptomPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Symptom.
     * @param {SymptomCreateArgs} args - Arguments to create a Symptom.
     * @example
     * // Create one Symptom
     * const Symptom = await prisma.symptom.create({
     *   data: {
     *     // ... data to create a Symptom
     *   }
     * })
     * 
     */
    create<T extends SymptomCreateArgs>(args: SelectSubset<T, SymptomCreateArgs<ExtArgs>>): Prisma__SymptomClient<$Result.GetResult<Prisma.$SymptomPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Symptoms.
     * @param {SymptomCreateManyArgs} args - Arguments to create many Symptoms.
     * @example
     * // Create many Symptoms
     * const symptom = await prisma.symptom.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SymptomCreateManyArgs>(args?: SelectSubset<T, SymptomCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Symptoms and returns the data saved in the database.
     * @param {SymptomCreateManyAndReturnArgs} args - Arguments to create many Symptoms.
     * @example
     * // Create many Symptoms
     * const symptom = await prisma.symptom.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Symptoms and only return the `id`
     * const symptomWithIdOnly = await prisma.symptom.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SymptomCreateManyAndReturnArgs>(args?: SelectSubset<T, SymptomCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SymptomPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Symptom.
     * @param {SymptomDeleteArgs} args - Arguments to delete one Symptom.
     * @example
     * // Delete one Symptom
     * const Symptom = await prisma.symptom.delete({
     *   where: {
     *     // ... filter to delete one Symptom
     *   }
     * })
     * 
     */
    delete<T extends SymptomDeleteArgs>(args: SelectSubset<T, SymptomDeleteArgs<ExtArgs>>): Prisma__SymptomClient<$Result.GetResult<Prisma.$SymptomPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Symptom.
     * @param {SymptomUpdateArgs} args - Arguments to update one Symptom.
     * @example
     * // Update one Symptom
     * const symptom = await prisma.symptom.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SymptomUpdateArgs>(args: SelectSubset<T, SymptomUpdateArgs<ExtArgs>>): Prisma__SymptomClient<$Result.GetResult<Prisma.$SymptomPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Symptoms.
     * @param {SymptomDeleteManyArgs} args - Arguments to filter Symptoms to delete.
     * @example
     * // Delete a few Symptoms
     * const { count } = await prisma.symptom.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SymptomDeleteManyArgs>(args?: SelectSubset<T, SymptomDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Symptoms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SymptomUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Symptoms
     * const symptom = await prisma.symptom.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SymptomUpdateManyArgs>(args: SelectSubset<T, SymptomUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Symptom.
     * @param {SymptomUpsertArgs} args - Arguments to update or create a Symptom.
     * @example
     * // Update or create a Symptom
     * const symptom = await prisma.symptom.upsert({
     *   create: {
     *     // ... data to create a Symptom
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Symptom we want to update
     *   }
     * })
     */
    upsert<T extends SymptomUpsertArgs>(args: SelectSubset<T, SymptomUpsertArgs<ExtArgs>>): Prisma__SymptomClient<$Result.GetResult<Prisma.$SymptomPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Symptoms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SymptomCountArgs} args - Arguments to filter Symptoms to count.
     * @example
     * // Count the number of Symptoms
     * const count = await prisma.symptom.count({
     *   where: {
     *     // ... the filter for the Symptoms we want to count
     *   }
     * })
    **/
    count<T extends SymptomCountArgs>(
      args?: Subset<T, SymptomCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SymptomCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Symptom.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SymptomAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SymptomAggregateArgs>(args: Subset<T, SymptomAggregateArgs>): Prisma.PrismaPromise<GetSymptomAggregateType<T>>

    /**
     * Group by Symptom.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SymptomGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SymptomGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SymptomGroupByArgs['orderBy'] }
        : { orderBy?: SymptomGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SymptomGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSymptomGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Symptom model
   */
  readonly fields: SymptomFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Symptom.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SymptomClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    correlations<T extends Symptom$correlationsArgs<ExtArgs> = {}>(args?: Subset<T, Symptom$correlationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CorrelationPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Symptom model
   */ 
  interface SymptomFieldRefs {
    readonly id: FieldRef<"Symptom", 'String'>
    readonly userId: FieldRef<"Symptom", 'String'>
    readonly name: FieldRef<"Symptom", 'String'>
    readonly severity: FieldRef<"Symptom", 'Int'>
    readonly startDate: FieldRef<"Symptom", 'DateTime'>
    readonly endDate: FieldRef<"Symptom", 'DateTime'>
    readonly notes: FieldRef<"Symptom", 'String'>
    readonly createdAt: FieldRef<"Symptom", 'DateTime'>
    readonly updatedAt: FieldRef<"Symptom", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Symptom findUnique
   */
  export type SymptomFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Symptom
     */
    select?: SymptomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SymptomInclude<ExtArgs> | null
    /**
     * Filter, which Symptom to fetch.
     */
    where: SymptomWhereUniqueInput
  }

  /**
   * Symptom findUniqueOrThrow
   */
  export type SymptomFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Symptom
     */
    select?: SymptomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SymptomInclude<ExtArgs> | null
    /**
     * Filter, which Symptom to fetch.
     */
    where: SymptomWhereUniqueInput
  }

  /**
   * Symptom findFirst
   */
  export type SymptomFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Symptom
     */
    select?: SymptomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SymptomInclude<ExtArgs> | null
    /**
     * Filter, which Symptom to fetch.
     */
    where?: SymptomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Symptoms to fetch.
     */
    orderBy?: SymptomOrderByWithRelationInput | SymptomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Symptoms.
     */
    cursor?: SymptomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Symptoms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Symptoms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Symptoms.
     */
    distinct?: SymptomScalarFieldEnum | SymptomScalarFieldEnum[]
  }

  /**
   * Symptom findFirstOrThrow
   */
  export type SymptomFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Symptom
     */
    select?: SymptomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SymptomInclude<ExtArgs> | null
    /**
     * Filter, which Symptom to fetch.
     */
    where?: SymptomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Symptoms to fetch.
     */
    orderBy?: SymptomOrderByWithRelationInput | SymptomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Symptoms.
     */
    cursor?: SymptomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Symptoms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Symptoms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Symptoms.
     */
    distinct?: SymptomScalarFieldEnum | SymptomScalarFieldEnum[]
  }

  /**
   * Symptom findMany
   */
  export type SymptomFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Symptom
     */
    select?: SymptomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SymptomInclude<ExtArgs> | null
    /**
     * Filter, which Symptoms to fetch.
     */
    where?: SymptomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Symptoms to fetch.
     */
    orderBy?: SymptomOrderByWithRelationInput | SymptomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Symptoms.
     */
    cursor?: SymptomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Symptoms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Symptoms.
     */
    skip?: number
    distinct?: SymptomScalarFieldEnum | SymptomScalarFieldEnum[]
  }

  /**
   * Symptom create
   */
  export type SymptomCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Symptom
     */
    select?: SymptomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SymptomInclude<ExtArgs> | null
    /**
     * The data needed to create a Symptom.
     */
    data: XOR<SymptomCreateInput, SymptomUncheckedCreateInput>
  }

  /**
   * Symptom createMany
   */
  export type SymptomCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Symptoms.
     */
    data: SymptomCreateManyInput | SymptomCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Symptom createManyAndReturn
   */
  export type SymptomCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Symptom
     */
    select?: SymptomSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Symptoms.
     */
    data: SymptomCreateManyInput | SymptomCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SymptomIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Symptom update
   */
  export type SymptomUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Symptom
     */
    select?: SymptomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SymptomInclude<ExtArgs> | null
    /**
     * The data needed to update a Symptom.
     */
    data: XOR<SymptomUpdateInput, SymptomUncheckedUpdateInput>
    /**
     * Choose, which Symptom to update.
     */
    where: SymptomWhereUniqueInput
  }

  /**
   * Symptom updateMany
   */
  export type SymptomUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Symptoms.
     */
    data: XOR<SymptomUpdateManyMutationInput, SymptomUncheckedUpdateManyInput>
    /**
     * Filter which Symptoms to update
     */
    where?: SymptomWhereInput
  }

  /**
   * Symptom upsert
   */
  export type SymptomUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Symptom
     */
    select?: SymptomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SymptomInclude<ExtArgs> | null
    /**
     * The filter to search for the Symptom to update in case it exists.
     */
    where: SymptomWhereUniqueInput
    /**
     * In case the Symptom found by the `where` argument doesn't exist, create a new Symptom with this data.
     */
    create: XOR<SymptomCreateInput, SymptomUncheckedCreateInput>
    /**
     * In case the Symptom was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SymptomUpdateInput, SymptomUncheckedUpdateInput>
  }

  /**
   * Symptom delete
   */
  export type SymptomDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Symptom
     */
    select?: SymptomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SymptomInclude<ExtArgs> | null
    /**
     * Filter which Symptom to delete.
     */
    where: SymptomWhereUniqueInput
  }

  /**
   * Symptom deleteMany
   */
  export type SymptomDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Symptoms to delete
     */
    where?: SymptomWhereInput
  }

  /**
   * Symptom.correlations
   */
  export type Symptom$correlationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Correlation
     */
    select?: CorrelationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CorrelationInclude<ExtArgs> | null
    where?: CorrelationWhereInput
    orderBy?: CorrelationOrderByWithRelationInput | CorrelationOrderByWithRelationInput[]
    cursor?: CorrelationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CorrelationScalarFieldEnum | CorrelationScalarFieldEnum[]
  }

  /**
   * Symptom without action
   */
  export type SymptomDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Symptom
     */
    select?: SymptomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SymptomInclude<ExtArgs> | null
  }


  /**
   * Model Medication
   */

  export type AggregateMedication = {
    _count: MedicationCountAggregateOutputType | null
    _min: MedicationMinAggregateOutputType | null
    _max: MedicationMaxAggregateOutputType | null
  }

  export type MedicationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    dosage: string | null
    frequency: string | null
    startDate: Date | null
    endDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MedicationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    dosage: string | null
    frequency: string | null
    startDate: Date | null
    endDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MedicationCountAggregateOutputType = {
    id: number
    userId: number
    name: number
    dosage: number
    frequency: number
    startDate: number
    endDate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MedicationMinAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    dosage?: true
    frequency?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MedicationMaxAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    dosage?: true
    frequency?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MedicationCountAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    dosage?: true
    frequency?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MedicationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Medication to aggregate.
     */
    where?: MedicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Medications to fetch.
     */
    orderBy?: MedicationOrderByWithRelationInput | MedicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MedicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Medications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Medications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Medications
    **/
    _count?: true | MedicationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MedicationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MedicationMaxAggregateInputType
  }

  export type GetMedicationAggregateType<T extends MedicationAggregateArgs> = {
        [P in keyof T & keyof AggregateMedication]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMedication[P]>
      : GetScalarType<T[P], AggregateMedication[P]>
  }




  export type MedicationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicationWhereInput
    orderBy?: MedicationOrderByWithAggregationInput | MedicationOrderByWithAggregationInput[]
    by: MedicationScalarFieldEnum[] | MedicationScalarFieldEnum
    having?: MedicationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MedicationCountAggregateInputType | true
    _min?: MedicationMinAggregateInputType
    _max?: MedicationMaxAggregateInputType
  }

  export type MedicationGroupByOutputType = {
    id: string
    userId: string
    name: string
    dosage: string | null
    frequency: string | null
    startDate: Date
    endDate: Date | null
    createdAt: Date
    updatedAt: Date
    _count: MedicationCountAggregateOutputType | null
    _min: MedicationMinAggregateOutputType | null
    _max: MedicationMaxAggregateOutputType | null
  }

  type GetMedicationGroupByPayload<T extends MedicationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MedicationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MedicationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MedicationGroupByOutputType[P]>
            : GetScalarType<T[P], MedicationGroupByOutputType[P]>
        }
      >
    >


  export type MedicationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    dosage?: boolean
    frequency?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["medication"]>

  export type MedicationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    dosage?: boolean
    frequency?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["medication"]>

  export type MedicationSelectScalar = {
    id?: boolean
    userId?: boolean
    name?: boolean
    dosage?: boolean
    frequency?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MedicationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MedicationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MedicationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Medication"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      name: string
      dosage: string | null
      frequency: string | null
      startDate: Date
      endDate: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["medication"]>
    composites: {}
  }

  type MedicationGetPayload<S extends boolean | null | undefined | MedicationDefaultArgs> = $Result.GetResult<Prisma.$MedicationPayload, S>

  type MedicationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MedicationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MedicationCountAggregateInputType | true
    }

  export interface MedicationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Medication'], meta: { name: 'Medication' } }
    /**
     * Find zero or one Medication that matches the filter.
     * @param {MedicationFindUniqueArgs} args - Arguments to find a Medication
     * @example
     * // Get one Medication
     * const medication = await prisma.medication.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MedicationFindUniqueArgs>(args: SelectSubset<T, MedicationFindUniqueArgs<ExtArgs>>): Prisma__MedicationClient<$Result.GetResult<Prisma.$MedicationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Medication that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MedicationFindUniqueOrThrowArgs} args - Arguments to find a Medication
     * @example
     * // Get one Medication
     * const medication = await prisma.medication.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MedicationFindUniqueOrThrowArgs>(args: SelectSubset<T, MedicationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MedicationClient<$Result.GetResult<Prisma.$MedicationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Medication that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicationFindFirstArgs} args - Arguments to find a Medication
     * @example
     * // Get one Medication
     * const medication = await prisma.medication.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MedicationFindFirstArgs>(args?: SelectSubset<T, MedicationFindFirstArgs<ExtArgs>>): Prisma__MedicationClient<$Result.GetResult<Prisma.$MedicationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Medication that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicationFindFirstOrThrowArgs} args - Arguments to find a Medication
     * @example
     * // Get one Medication
     * const medication = await prisma.medication.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MedicationFindFirstOrThrowArgs>(args?: SelectSubset<T, MedicationFindFirstOrThrowArgs<ExtArgs>>): Prisma__MedicationClient<$Result.GetResult<Prisma.$MedicationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Medications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Medications
     * const medications = await prisma.medication.findMany()
     * 
     * // Get first 10 Medications
     * const medications = await prisma.medication.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const medicationWithIdOnly = await prisma.medication.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MedicationFindManyArgs>(args?: SelectSubset<T, MedicationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Medication.
     * @param {MedicationCreateArgs} args - Arguments to create a Medication.
     * @example
     * // Create one Medication
     * const Medication = await prisma.medication.create({
     *   data: {
     *     // ... data to create a Medication
     *   }
     * })
     * 
     */
    create<T extends MedicationCreateArgs>(args: SelectSubset<T, MedicationCreateArgs<ExtArgs>>): Prisma__MedicationClient<$Result.GetResult<Prisma.$MedicationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Medications.
     * @param {MedicationCreateManyArgs} args - Arguments to create many Medications.
     * @example
     * // Create many Medications
     * const medication = await prisma.medication.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MedicationCreateManyArgs>(args?: SelectSubset<T, MedicationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Medications and returns the data saved in the database.
     * @param {MedicationCreateManyAndReturnArgs} args - Arguments to create many Medications.
     * @example
     * // Create many Medications
     * const medication = await prisma.medication.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Medications and only return the `id`
     * const medicationWithIdOnly = await prisma.medication.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MedicationCreateManyAndReturnArgs>(args?: SelectSubset<T, MedicationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Medication.
     * @param {MedicationDeleteArgs} args - Arguments to delete one Medication.
     * @example
     * // Delete one Medication
     * const Medication = await prisma.medication.delete({
     *   where: {
     *     // ... filter to delete one Medication
     *   }
     * })
     * 
     */
    delete<T extends MedicationDeleteArgs>(args: SelectSubset<T, MedicationDeleteArgs<ExtArgs>>): Prisma__MedicationClient<$Result.GetResult<Prisma.$MedicationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Medication.
     * @param {MedicationUpdateArgs} args - Arguments to update one Medication.
     * @example
     * // Update one Medication
     * const medication = await prisma.medication.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MedicationUpdateArgs>(args: SelectSubset<T, MedicationUpdateArgs<ExtArgs>>): Prisma__MedicationClient<$Result.GetResult<Prisma.$MedicationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Medications.
     * @param {MedicationDeleteManyArgs} args - Arguments to filter Medications to delete.
     * @example
     * // Delete a few Medications
     * const { count } = await prisma.medication.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MedicationDeleteManyArgs>(args?: SelectSubset<T, MedicationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Medications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Medications
     * const medication = await prisma.medication.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MedicationUpdateManyArgs>(args: SelectSubset<T, MedicationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Medication.
     * @param {MedicationUpsertArgs} args - Arguments to update or create a Medication.
     * @example
     * // Update or create a Medication
     * const medication = await prisma.medication.upsert({
     *   create: {
     *     // ... data to create a Medication
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Medication we want to update
     *   }
     * })
     */
    upsert<T extends MedicationUpsertArgs>(args: SelectSubset<T, MedicationUpsertArgs<ExtArgs>>): Prisma__MedicationClient<$Result.GetResult<Prisma.$MedicationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Medications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicationCountArgs} args - Arguments to filter Medications to count.
     * @example
     * // Count the number of Medications
     * const count = await prisma.medication.count({
     *   where: {
     *     // ... the filter for the Medications we want to count
     *   }
     * })
    **/
    count<T extends MedicationCountArgs>(
      args?: Subset<T, MedicationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MedicationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Medication.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MedicationAggregateArgs>(args: Subset<T, MedicationAggregateArgs>): Prisma.PrismaPromise<GetMedicationAggregateType<T>>

    /**
     * Group by Medication.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MedicationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MedicationGroupByArgs['orderBy'] }
        : { orderBy?: MedicationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MedicationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMedicationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Medication model
   */
  readonly fields: MedicationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Medication.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MedicationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Medication model
   */ 
  interface MedicationFieldRefs {
    readonly id: FieldRef<"Medication", 'String'>
    readonly userId: FieldRef<"Medication", 'String'>
    readonly name: FieldRef<"Medication", 'String'>
    readonly dosage: FieldRef<"Medication", 'String'>
    readonly frequency: FieldRef<"Medication", 'String'>
    readonly startDate: FieldRef<"Medication", 'DateTime'>
    readonly endDate: FieldRef<"Medication", 'DateTime'>
    readonly createdAt: FieldRef<"Medication", 'DateTime'>
    readonly updatedAt: FieldRef<"Medication", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Medication findUnique
   */
  export type MedicationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medication
     */
    select?: MedicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationInclude<ExtArgs> | null
    /**
     * Filter, which Medication to fetch.
     */
    where: MedicationWhereUniqueInput
  }

  /**
   * Medication findUniqueOrThrow
   */
  export type MedicationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medication
     */
    select?: MedicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationInclude<ExtArgs> | null
    /**
     * Filter, which Medication to fetch.
     */
    where: MedicationWhereUniqueInput
  }

  /**
   * Medication findFirst
   */
  export type MedicationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medication
     */
    select?: MedicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationInclude<ExtArgs> | null
    /**
     * Filter, which Medication to fetch.
     */
    where?: MedicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Medications to fetch.
     */
    orderBy?: MedicationOrderByWithRelationInput | MedicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Medications.
     */
    cursor?: MedicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Medications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Medications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Medications.
     */
    distinct?: MedicationScalarFieldEnum | MedicationScalarFieldEnum[]
  }

  /**
   * Medication findFirstOrThrow
   */
  export type MedicationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medication
     */
    select?: MedicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationInclude<ExtArgs> | null
    /**
     * Filter, which Medication to fetch.
     */
    where?: MedicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Medications to fetch.
     */
    orderBy?: MedicationOrderByWithRelationInput | MedicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Medications.
     */
    cursor?: MedicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Medications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Medications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Medications.
     */
    distinct?: MedicationScalarFieldEnum | MedicationScalarFieldEnum[]
  }

  /**
   * Medication findMany
   */
  export type MedicationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medication
     */
    select?: MedicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationInclude<ExtArgs> | null
    /**
     * Filter, which Medications to fetch.
     */
    where?: MedicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Medications to fetch.
     */
    orderBy?: MedicationOrderByWithRelationInput | MedicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Medications.
     */
    cursor?: MedicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Medications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Medications.
     */
    skip?: number
    distinct?: MedicationScalarFieldEnum | MedicationScalarFieldEnum[]
  }

  /**
   * Medication create
   */
  export type MedicationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medication
     */
    select?: MedicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationInclude<ExtArgs> | null
    /**
     * The data needed to create a Medication.
     */
    data: XOR<MedicationCreateInput, MedicationUncheckedCreateInput>
  }

  /**
   * Medication createMany
   */
  export type MedicationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Medications.
     */
    data: MedicationCreateManyInput | MedicationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Medication createManyAndReturn
   */
  export type MedicationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medication
     */
    select?: MedicationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Medications.
     */
    data: MedicationCreateManyInput | MedicationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Medication update
   */
  export type MedicationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medication
     */
    select?: MedicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationInclude<ExtArgs> | null
    /**
     * The data needed to update a Medication.
     */
    data: XOR<MedicationUpdateInput, MedicationUncheckedUpdateInput>
    /**
     * Choose, which Medication to update.
     */
    where: MedicationWhereUniqueInput
  }

  /**
   * Medication updateMany
   */
  export type MedicationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Medications.
     */
    data: XOR<MedicationUpdateManyMutationInput, MedicationUncheckedUpdateManyInput>
    /**
     * Filter which Medications to update
     */
    where?: MedicationWhereInput
  }

  /**
   * Medication upsert
   */
  export type MedicationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medication
     */
    select?: MedicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationInclude<ExtArgs> | null
    /**
     * The filter to search for the Medication to update in case it exists.
     */
    where: MedicationWhereUniqueInput
    /**
     * In case the Medication found by the `where` argument doesn't exist, create a new Medication with this data.
     */
    create: XOR<MedicationCreateInput, MedicationUncheckedCreateInput>
    /**
     * In case the Medication was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MedicationUpdateInput, MedicationUncheckedUpdateInput>
  }

  /**
   * Medication delete
   */
  export type MedicationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medication
     */
    select?: MedicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationInclude<ExtArgs> | null
    /**
     * Filter which Medication to delete.
     */
    where: MedicationWhereUniqueInput
  }

  /**
   * Medication deleteMany
   */
  export type MedicationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Medications to delete
     */
    where?: MedicationWhereInput
  }

  /**
   * Medication without action
   */
  export type MedicationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medication
     */
    select?: MedicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationInclude<ExtArgs> | null
  }


  /**
   * Model Correlation
   */

  export type AggregateCorrelation = {
    _count: CorrelationCountAggregateOutputType | null
    _avg: CorrelationAvgAggregateOutputType | null
    _sum: CorrelationSumAggregateOutputType | null
    _min: CorrelationMinAggregateOutputType | null
    _max: CorrelationMaxAggregateOutputType | null
  }

  export type CorrelationAvgAggregateOutputType = {
    strength: number | null
    confidence: number | null
  }

  export type CorrelationSumAggregateOutputType = {
    strength: number | null
    confidence: number | null
  }

  export type CorrelationMinAggregateOutputType = {
    id: string | null
    biomarkerId: string | null
    symptomId: string | null
    strength: number | null
    direction: string | null
    confidence: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CorrelationMaxAggregateOutputType = {
    id: string | null
    biomarkerId: string | null
    symptomId: string | null
    strength: number | null
    direction: string | null
    confidence: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CorrelationCountAggregateOutputType = {
    id: number
    biomarkerId: number
    symptomId: number
    strength: number
    direction: number
    confidence: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CorrelationAvgAggregateInputType = {
    strength?: true
    confidence?: true
  }

  export type CorrelationSumAggregateInputType = {
    strength?: true
    confidence?: true
  }

  export type CorrelationMinAggregateInputType = {
    id?: true
    biomarkerId?: true
    symptomId?: true
    strength?: true
    direction?: true
    confidence?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CorrelationMaxAggregateInputType = {
    id?: true
    biomarkerId?: true
    symptomId?: true
    strength?: true
    direction?: true
    confidence?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CorrelationCountAggregateInputType = {
    id?: true
    biomarkerId?: true
    symptomId?: true
    strength?: true
    direction?: true
    confidence?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CorrelationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Correlation to aggregate.
     */
    where?: CorrelationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Correlations to fetch.
     */
    orderBy?: CorrelationOrderByWithRelationInput | CorrelationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CorrelationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Correlations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Correlations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Correlations
    **/
    _count?: true | CorrelationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CorrelationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CorrelationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CorrelationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CorrelationMaxAggregateInputType
  }

  export type GetCorrelationAggregateType<T extends CorrelationAggregateArgs> = {
        [P in keyof T & keyof AggregateCorrelation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCorrelation[P]>
      : GetScalarType<T[P], AggregateCorrelation[P]>
  }




  export type CorrelationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CorrelationWhereInput
    orderBy?: CorrelationOrderByWithAggregationInput | CorrelationOrderByWithAggregationInput[]
    by: CorrelationScalarFieldEnum[] | CorrelationScalarFieldEnum
    having?: CorrelationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CorrelationCountAggregateInputType | true
    _avg?: CorrelationAvgAggregateInputType
    _sum?: CorrelationSumAggregateInputType
    _min?: CorrelationMinAggregateInputType
    _max?: CorrelationMaxAggregateInputType
  }

  export type CorrelationGroupByOutputType = {
    id: string
    biomarkerId: string
    symptomId: string
    strength: number
    direction: string
    confidence: number
    createdAt: Date
    updatedAt: Date
    _count: CorrelationCountAggregateOutputType | null
    _avg: CorrelationAvgAggregateOutputType | null
    _sum: CorrelationSumAggregateOutputType | null
    _min: CorrelationMinAggregateOutputType | null
    _max: CorrelationMaxAggregateOutputType | null
  }

  type GetCorrelationGroupByPayload<T extends CorrelationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CorrelationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CorrelationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CorrelationGroupByOutputType[P]>
            : GetScalarType<T[P], CorrelationGroupByOutputType[P]>
        }
      >
    >


  export type CorrelationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    biomarkerId?: boolean
    symptomId?: boolean
    strength?: boolean
    direction?: boolean
    confidence?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    biomarker?: boolean | BiomarkerDefaultArgs<ExtArgs>
    symptom?: boolean | SymptomDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["correlation"]>

  export type CorrelationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    biomarkerId?: boolean
    symptomId?: boolean
    strength?: boolean
    direction?: boolean
    confidence?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    biomarker?: boolean | BiomarkerDefaultArgs<ExtArgs>
    symptom?: boolean | SymptomDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["correlation"]>

  export type CorrelationSelectScalar = {
    id?: boolean
    biomarkerId?: boolean
    symptomId?: boolean
    strength?: boolean
    direction?: boolean
    confidence?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CorrelationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    biomarker?: boolean | BiomarkerDefaultArgs<ExtArgs>
    symptom?: boolean | SymptomDefaultArgs<ExtArgs>
  }
  export type CorrelationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    biomarker?: boolean | BiomarkerDefaultArgs<ExtArgs>
    symptom?: boolean | SymptomDefaultArgs<ExtArgs>
  }

  export type $CorrelationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Correlation"
    objects: {
      biomarker: Prisma.$BiomarkerPayload<ExtArgs>
      symptom: Prisma.$SymptomPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      biomarkerId: string
      symptomId: string
      strength: number
      direction: string
      confidence: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["correlation"]>
    composites: {}
  }

  type CorrelationGetPayload<S extends boolean | null | undefined | CorrelationDefaultArgs> = $Result.GetResult<Prisma.$CorrelationPayload, S>

  type CorrelationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CorrelationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CorrelationCountAggregateInputType | true
    }

  export interface CorrelationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Correlation'], meta: { name: 'Correlation' } }
    /**
     * Find zero or one Correlation that matches the filter.
     * @param {CorrelationFindUniqueArgs} args - Arguments to find a Correlation
     * @example
     * // Get one Correlation
     * const correlation = await prisma.correlation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CorrelationFindUniqueArgs>(args: SelectSubset<T, CorrelationFindUniqueArgs<ExtArgs>>): Prisma__CorrelationClient<$Result.GetResult<Prisma.$CorrelationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Correlation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CorrelationFindUniqueOrThrowArgs} args - Arguments to find a Correlation
     * @example
     * // Get one Correlation
     * const correlation = await prisma.correlation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CorrelationFindUniqueOrThrowArgs>(args: SelectSubset<T, CorrelationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CorrelationClient<$Result.GetResult<Prisma.$CorrelationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Correlation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CorrelationFindFirstArgs} args - Arguments to find a Correlation
     * @example
     * // Get one Correlation
     * const correlation = await prisma.correlation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CorrelationFindFirstArgs>(args?: SelectSubset<T, CorrelationFindFirstArgs<ExtArgs>>): Prisma__CorrelationClient<$Result.GetResult<Prisma.$CorrelationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Correlation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CorrelationFindFirstOrThrowArgs} args - Arguments to find a Correlation
     * @example
     * // Get one Correlation
     * const correlation = await prisma.correlation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CorrelationFindFirstOrThrowArgs>(args?: SelectSubset<T, CorrelationFindFirstOrThrowArgs<ExtArgs>>): Prisma__CorrelationClient<$Result.GetResult<Prisma.$CorrelationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Correlations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CorrelationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Correlations
     * const correlations = await prisma.correlation.findMany()
     * 
     * // Get first 10 Correlations
     * const correlations = await prisma.correlation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const correlationWithIdOnly = await prisma.correlation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CorrelationFindManyArgs>(args?: SelectSubset<T, CorrelationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CorrelationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Correlation.
     * @param {CorrelationCreateArgs} args - Arguments to create a Correlation.
     * @example
     * // Create one Correlation
     * const Correlation = await prisma.correlation.create({
     *   data: {
     *     // ... data to create a Correlation
     *   }
     * })
     * 
     */
    create<T extends CorrelationCreateArgs>(args: SelectSubset<T, CorrelationCreateArgs<ExtArgs>>): Prisma__CorrelationClient<$Result.GetResult<Prisma.$CorrelationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Correlations.
     * @param {CorrelationCreateManyArgs} args - Arguments to create many Correlations.
     * @example
     * // Create many Correlations
     * const correlation = await prisma.correlation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CorrelationCreateManyArgs>(args?: SelectSubset<T, CorrelationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Correlations and returns the data saved in the database.
     * @param {CorrelationCreateManyAndReturnArgs} args - Arguments to create many Correlations.
     * @example
     * // Create many Correlations
     * const correlation = await prisma.correlation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Correlations and only return the `id`
     * const correlationWithIdOnly = await prisma.correlation.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CorrelationCreateManyAndReturnArgs>(args?: SelectSubset<T, CorrelationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CorrelationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Correlation.
     * @param {CorrelationDeleteArgs} args - Arguments to delete one Correlation.
     * @example
     * // Delete one Correlation
     * const Correlation = await prisma.correlation.delete({
     *   where: {
     *     // ... filter to delete one Correlation
     *   }
     * })
     * 
     */
    delete<T extends CorrelationDeleteArgs>(args: SelectSubset<T, CorrelationDeleteArgs<ExtArgs>>): Prisma__CorrelationClient<$Result.GetResult<Prisma.$CorrelationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Correlation.
     * @param {CorrelationUpdateArgs} args - Arguments to update one Correlation.
     * @example
     * // Update one Correlation
     * const correlation = await prisma.correlation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CorrelationUpdateArgs>(args: SelectSubset<T, CorrelationUpdateArgs<ExtArgs>>): Prisma__CorrelationClient<$Result.GetResult<Prisma.$CorrelationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Correlations.
     * @param {CorrelationDeleteManyArgs} args - Arguments to filter Correlations to delete.
     * @example
     * // Delete a few Correlations
     * const { count } = await prisma.correlation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CorrelationDeleteManyArgs>(args?: SelectSubset<T, CorrelationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Correlations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CorrelationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Correlations
     * const correlation = await prisma.correlation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CorrelationUpdateManyArgs>(args: SelectSubset<T, CorrelationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Correlation.
     * @param {CorrelationUpsertArgs} args - Arguments to update or create a Correlation.
     * @example
     * // Update or create a Correlation
     * const correlation = await prisma.correlation.upsert({
     *   create: {
     *     // ... data to create a Correlation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Correlation we want to update
     *   }
     * })
     */
    upsert<T extends CorrelationUpsertArgs>(args: SelectSubset<T, CorrelationUpsertArgs<ExtArgs>>): Prisma__CorrelationClient<$Result.GetResult<Prisma.$CorrelationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Correlations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CorrelationCountArgs} args - Arguments to filter Correlations to count.
     * @example
     * // Count the number of Correlations
     * const count = await prisma.correlation.count({
     *   where: {
     *     // ... the filter for the Correlations we want to count
     *   }
     * })
    **/
    count<T extends CorrelationCountArgs>(
      args?: Subset<T, CorrelationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CorrelationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Correlation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CorrelationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CorrelationAggregateArgs>(args: Subset<T, CorrelationAggregateArgs>): Prisma.PrismaPromise<GetCorrelationAggregateType<T>>

    /**
     * Group by Correlation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CorrelationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CorrelationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CorrelationGroupByArgs['orderBy'] }
        : { orderBy?: CorrelationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CorrelationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCorrelationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Correlation model
   */
  readonly fields: CorrelationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Correlation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CorrelationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    biomarker<T extends BiomarkerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BiomarkerDefaultArgs<ExtArgs>>): Prisma__BiomarkerClient<$Result.GetResult<Prisma.$BiomarkerPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    symptom<T extends SymptomDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SymptomDefaultArgs<ExtArgs>>): Prisma__SymptomClient<$Result.GetResult<Prisma.$SymptomPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Correlation model
   */ 
  interface CorrelationFieldRefs {
    readonly id: FieldRef<"Correlation", 'String'>
    readonly biomarkerId: FieldRef<"Correlation", 'String'>
    readonly symptomId: FieldRef<"Correlation", 'String'>
    readonly strength: FieldRef<"Correlation", 'Float'>
    readonly direction: FieldRef<"Correlation", 'String'>
    readonly confidence: FieldRef<"Correlation", 'Float'>
    readonly createdAt: FieldRef<"Correlation", 'DateTime'>
    readonly updatedAt: FieldRef<"Correlation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Correlation findUnique
   */
  export type CorrelationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Correlation
     */
    select?: CorrelationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CorrelationInclude<ExtArgs> | null
    /**
     * Filter, which Correlation to fetch.
     */
    where: CorrelationWhereUniqueInput
  }

  /**
   * Correlation findUniqueOrThrow
   */
  export type CorrelationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Correlation
     */
    select?: CorrelationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CorrelationInclude<ExtArgs> | null
    /**
     * Filter, which Correlation to fetch.
     */
    where: CorrelationWhereUniqueInput
  }

  /**
   * Correlation findFirst
   */
  export type CorrelationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Correlation
     */
    select?: CorrelationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CorrelationInclude<ExtArgs> | null
    /**
     * Filter, which Correlation to fetch.
     */
    where?: CorrelationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Correlations to fetch.
     */
    orderBy?: CorrelationOrderByWithRelationInput | CorrelationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Correlations.
     */
    cursor?: CorrelationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Correlations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Correlations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Correlations.
     */
    distinct?: CorrelationScalarFieldEnum | CorrelationScalarFieldEnum[]
  }

  /**
   * Correlation findFirstOrThrow
   */
  export type CorrelationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Correlation
     */
    select?: CorrelationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CorrelationInclude<ExtArgs> | null
    /**
     * Filter, which Correlation to fetch.
     */
    where?: CorrelationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Correlations to fetch.
     */
    orderBy?: CorrelationOrderByWithRelationInput | CorrelationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Correlations.
     */
    cursor?: CorrelationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Correlations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Correlations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Correlations.
     */
    distinct?: CorrelationScalarFieldEnum | CorrelationScalarFieldEnum[]
  }

  /**
   * Correlation findMany
   */
  export type CorrelationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Correlation
     */
    select?: CorrelationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CorrelationInclude<ExtArgs> | null
    /**
     * Filter, which Correlations to fetch.
     */
    where?: CorrelationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Correlations to fetch.
     */
    orderBy?: CorrelationOrderByWithRelationInput | CorrelationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Correlations.
     */
    cursor?: CorrelationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Correlations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Correlations.
     */
    skip?: number
    distinct?: CorrelationScalarFieldEnum | CorrelationScalarFieldEnum[]
  }

  /**
   * Correlation create
   */
  export type CorrelationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Correlation
     */
    select?: CorrelationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CorrelationInclude<ExtArgs> | null
    /**
     * The data needed to create a Correlation.
     */
    data: XOR<CorrelationCreateInput, CorrelationUncheckedCreateInput>
  }

  /**
   * Correlation createMany
   */
  export type CorrelationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Correlations.
     */
    data: CorrelationCreateManyInput | CorrelationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Correlation createManyAndReturn
   */
  export type CorrelationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Correlation
     */
    select?: CorrelationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Correlations.
     */
    data: CorrelationCreateManyInput | CorrelationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CorrelationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Correlation update
   */
  export type CorrelationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Correlation
     */
    select?: CorrelationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CorrelationInclude<ExtArgs> | null
    /**
     * The data needed to update a Correlation.
     */
    data: XOR<CorrelationUpdateInput, CorrelationUncheckedUpdateInput>
    /**
     * Choose, which Correlation to update.
     */
    where: CorrelationWhereUniqueInput
  }

  /**
   * Correlation updateMany
   */
  export type CorrelationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Correlations.
     */
    data: XOR<CorrelationUpdateManyMutationInput, CorrelationUncheckedUpdateManyInput>
    /**
     * Filter which Correlations to update
     */
    where?: CorrelationWhereInput
  }

  /**
   * Correlation upsert
   */
  export type CorrelationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Correlation
     */
    select?: CorrelationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CorrelationInclude<ExtArgs> | null
    /**
     * The filter to search for the Correlation to update in case it exists.
     */
    where: CorrelationWhereUniqueInput
    /**
     * In case the Correlation found by the `where` argument doesn't exist, create a new Correlation with this data.
     */
    create: XOR<CorrelationCreateInput, CorrelationUncheckedCreateInput>
    /**
     * In case the Correlation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CorrelationUpdateInput, CorrelationUncheckedUpdateInput>
  }

  /**
   * Correlation delete
   */
  export type CorrelationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Correlation
     */
    select?: CorrelationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CorrelationInclude<ExtArgs> | null
    /**
     * Filter which Correlation to delete.
     */
    where: CorrelationWhereUniqueInput
  }

  /**
   * Correlation deleteMany
   */
  export type CorrelationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Correlations to delete
     */
    where?: CorrelationWhereInput
  }

  /**
   * Correlation without action
   */
  export type CorrelationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Correlation
     */
    select?: CorrelationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CorrelationInclude<ExtArgs> | null
  }


  /**
   * Model RiskAssessment
   */

  export type AggregateRiskAssessment = {
    _count: RiskAssessmentCountAggregateOutputType | null
    _avg: RiskAssessmentAvgAggregateOutputType | null
    _sum: RiskAssessmentSumAggregateOutputType | null
    _min: RiskAssessmentMinAggregateOutputType | null
    _max: RiskAssessmentMaxAggregateOutputType | null
  }

  export type RiskAssessmentAvgAggregateOutputType = {
    score: number | null
    confidence: number | null
  }

  export type RiskAssessmentSumAggregateOutputType = {
    score: number | null
    confidence: number | null
  }

  export type RiskAssessmentMinAggregateOutputType = {
    id: string | null
    userId: string | null
    riskType: string | null
    score: number | null
    confidence: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RiskAssessmentMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    riskType: string | null
    score: number | null
    confidence: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RiskAssessmentCountAggregateOutputType = {
    id: number
    userId: number
    riskType: number
    score: number
    confidence: number
    factors: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RiskAssessmentAvgAggregateInputType = {
    score?: true
    confidence?: true
  }

  export type RiskAssessmentSumAggregateInputType = {
    score?: true
    confidence?: true
  }

  export type RiskAssessmentMinAggregateInputType = {
    id?: true
    userId?: true
    riskType?: true
    score?: true
    confidence?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RiskAssessmentMaxAggregateInputType = {
    id?: true
    userId?: true
    riskType?: true
    score?: true
    confidence?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RiskAssessmentCountAggregateInputType = {
    id?: true
    userId?: true
    riskType?: true
    score?: true
    confidence?: true
    factors?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RiskAssessmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RiskAssessment to aggregate.
     */
    where?: RiskAssessmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RiskAssessments to fetch.
     */
    orderBy?: RiskAssessmentOrderByWithRelationInput | RiskAssessmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RiskAssessmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RiskAssessments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RiskAssessments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RiskAssessments
    **/
    _count?: true | RiskAssessmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RiskAssessmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RiskAssessmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RiskAssessmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RiskAssessmentMaxAggregateInputType
  }

  export type GetRiskAssessmentAggregateType<T extends RiskAssessmentAggregateArgs> = {
        [P in keyof T & keyof AggregateRiskAssessment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRiskAssessment[P]>
      : GetScalarType<T[P], AggregateRiskAssessment[P]>
  }




  export type RiskAssessmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RiskAssessmentWhereInput
    orderBy?: RiskAssessmentOrderByWithAggregationInput | RiskAssessmentOrderByWithAggregationInput[]
    by: RiskAssessmentScalarFieldEnum[] | RiskAssessmentScalarFieldEnum
    having?: RiskAssessmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RiskAssessmentCountAggregateInputType | true
    _avg?: RiskAssessmentAvgAggregateInputType
    _sum?: RiskAssessmentSumAggregateInputType
    _min?: RiskAssessmentMinAggregateInputType
    _max?: RiskAssessmentMaxAggregateInputType
  }

  export type RiskAssessmentGroupByOutputType = {
    id: string
    userId: string
    riskType: string
    score: number
    confidence: number
    factors: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: RiskAssessmentCountAggregateOutputType | null
    _avg: RiskAssessmentAvgAggregateOutputType | null
    _sum: RiskAssessmentSumAggregateOutputType | null
    _min: RiskAssessmentMinAggregateOutputType | null
    _max: RiskAssessmentMaxAggregateOutputType | null
  }

  type GetRiskAssessmentGroupByPayload<T extends RiskAssessmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RiskAssessmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RiskAssessmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RiskAssessmentGroupByOutputType[P]>
            : GetScalarType<T[P], RiskAssessmentGroupByOutputType[P]>
        }
      >
    >


  export type RiskAssessmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    riskType?: boolean
    score?: boolean
    confidence?: boolean
    factors?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["riskAssessment"]>

  export type RiskAssessmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    riskType?: boolean
    score?: boolean
    confidence?: boolean
    factors?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["riskAssessment"]>

  export type RiskAssessmentSelectScalar = {
    id?: boolean
    userId?: boolean
    riskType?: boolean
    score?: boolean
    confidence?: boolean
    factors?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $RiskAssessmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RiskAssessment"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      riskType: string
      score: number
      confidence: number
      factors: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["riskAssessment"]>
    composites: {}
  }

  type RiskAssessmentGetPayload<S extends boolean | null | undefined | RiskAssessmentDefaultArgs> = $Result.GetResult<Prisma.$RiskAssessmentPayload, S>

  type RiskAssessmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RiskAssessmentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RiskAssessmentCountAggregateInputType | true
    }

  export interface RiskAssessmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RiskAssessment'], meta: { name: 'RiskAssessment' } }
    /**
     * Find zero or one RiskAssessment that matches the filter.
     * @param {RiskAssessmentFindUniqueArgs} args - Arguments to find a RiskAssessment
     * @example
     * // Get one RiskAssessment
     * const riskAssessment = await prisma.riskAssessment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RiskAssessmentFindUniqueArgs>(args: SelectSubset<T, RiskAssessmentFindUniqueArgs<ExtArgs>>): Prisma__RiskAssessmentClient<$Result.GetResult<Prisma.$RiskAssessmentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RiskAssessment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RiskAssessmentFindUniqueOrThrowArgs} args - Arguments to find a RiskAssessment
     * @example
     * // Get one RiskAssessment
     * const riskAssessment = await prisma.riskAssessment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RiskAssessmentFindUniqueOrThrowArgs>(args: SelectSubset<T, RiskAssessmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RiskAssessmentClient<$Result.GetResult<Prisma.$RiskAssessmentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RiskAssessment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskAssessmentFindFirstArgs} args - Arguments to find a RiskAssessment
     * @example
     * // Get one RiskAssessment
     * const riskAssessment = await prisma.riskAssessment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RiskAssessmentFindFirstArgs>(args?: SelectSubset<T, RiskAssessmentFindFirstArgs<ExtArgs>>): Prisma__RiskAssessmentClient<$Result.GetResult<Prisma.$RiskAssessmentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RiskAssessment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskAssessmentFindFirstOrThrowArgs} args - Arguments to find a RiskAssessment
     * @example
     * // Get one RiskAssessment
     * const riskAssessment = await prisma.riskAssessment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RiskAssessmentFindFirstOrThrowArgs>(args?: SelectSubset<T, RiskAssessmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__RiskAssessmentClient<$Result.GetResult<Prisma.$RiskAssessmentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RiskAssessments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskAssessmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RiskAssessments
     * const riskAssessments = await prisma.riskAssessment.findMany()
     * 
     * // Get first 10 RiskAssessments
     * const riskAssessments = await prisma.riskAssessment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const riskAssessmentWithIdOnly = await prisma.riskAssessment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RiskAssessmentFindManyArgs>(args?: SelectSubset<T, RiskAssessmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RiskAssessmentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RiskAssessment.
     * @param {RiskAssessmentCreateArgs} args - Arguments to create a RiskAssessment.
     * @example
     * // Create one RiskAssessment
     * const RiskAssessment = await prisma.riskAssessment.create({
     *   data: {
     *     // ... data to create a RiskAssessment
     *   }
     * })
     * 
     */
    create<T extends RiskAssessmentCreateArgs>(args: SelectSubset<T, RiskAssessmentCreateArgs<ExtArgs>>): Prisma__RiskAssessmentClient<$Result.GetResult<Prisma.$RiskAssessmentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RiskAssessments.
     * @param {RiskAssessmentCreateManyArgs} args - Arguments to create many RiskAssessments.
     * @example
     * // Create many RiskAssessments
     * const riskAssessment = await prisma.riskAssessment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RiskAssessmentCreateManyArgs>(args?: SelectSubset<T, RiskAssessmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RiskAssessments and returns the data saved in the database.
     * @param {RiskAssessmentCreateManyAndReturnArgs} args - Arguments to create many RiskAssessments.
     * @example
     * // Create many RiskAssessments
     * const riskAssessment = await prisma.riskAssessment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RiskAssessments and only return the `id`
     * const riskAssessmentWithIdOnly = await prisma.riskAssessment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RiskAssessmentCreateManyAndReturnArgs>(args?: SelectSubset<T, RiskAssessmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RiskAssessmentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RiskAssessment.
     * @param {RiskAssessmentDeleteArgs} args - Arguments to delete one RiskAssessment.
     * @example
     * // Delete one RiskAssessment
     * const RiskAssessment = await prisma.riskAssessment.delete({
     *   where: {
     *     // ... filter to delete one RiskAssessment
     *   }
     * })
     * 
     */
    delete<T extends RiskAssessmentDeleteArgs>(args: SelectSubset<T, RiskAssessmentDeleteArgs<ExtArgs>>): Prisma__RiskAssessmentClient<$Result.GetResult<Prisma.$RiskAssessmentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RiskAssessment.
     * @param {RiskAssessmentUpdateArgs} args - Arguments to update one RiskAssessment.
     * @example
     * // Update one RiskAssessment
     * const riskAssessment = await prisma.riskAssessment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RiskAssessmentUpdateArgs>(args: SelectSubset<T, RiskAssessmentUpdateArgs<ExtArgs>>): Prisma__RiskAssessmentClient<$Result.GetResult<Prisma.$RiskAssessmentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RiskAssessments.
     * @param {RiskAssessmentDeleteManyArgs} args - Arguments to filter RiskAssessments to delete.
     * @example
     * // Delete a few RiskAssessments
     * const { count } = await prisma.riskAssessment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RiskAssessmentDeleteManyArgs>(args?: SelectSubset<T, RiskAssessmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RiskAssessments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskAssessmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RiskAssessments
     * const riskAssessment = await prisma.riskAssessment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RiskAssessmentUpdateManyArgs>(args: SelectSubset<T, RiskAssessmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RiskAssessment.
     * @param {RiskAssessmentUpsertArgs} args - Arguments to update or create a RiskAssessment.
     * @example
     * // Update or create a RiskAssessment
     * const riskAssessment = await prisma.riskAssessment.upsert({
     *   create: {
     *     // ... data to create a RiskAssessment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RiskAssessment we want to update
     *   }
     * })
     */
    upsert<T extends RiskAssessmentUpsertArgs>(args: SelectSubset<T, RiskAssessmentUpsertArgs<ExtArgs>>): Prisma__RiskAssessmentClient<$Result.GetResult<Prisma.$RiskAssessmentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RiskAssessments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskAssessmentCountArgs} args - Arguments to filter RiskAssessments to count.
     * @example
     * // Count the number of RiskAssessments
     * const count = await prisma.riskAssessment.count({
     *   where: {
     *     // ... the filter for the RiskAssessments we want to count
     *   }
     * })
    **/
    count<T extends RiskAssessmentCountArgs>(
      args?: Subset<T, RiskAssessmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RiskAssessmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RiskAssessment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskAssessmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RiskAssessmentAggregateArgs>(args: Subset<T, RiskAssessmentAggregateArgs>): Prisma.PrismaPromise<GetRiskAssessmentAggregateType<T>>

    /**
     * Group by RiskAssessment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskAssessmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RiskAssessmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RiskAssessmentGroupByArgs['orderBy'] }
        : { orderBy?: RiskAssessmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RiskAssessmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRiskAssessmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RiskAssessment model
   */
  readonly fields: RiskAssessmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RiskAssessment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RiskAssessmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RiskAssessment model
   */ 
  interface RiskAssessmentFieldRefs {
    readonly id: FieldRef<"RiskAssessment", 'String'>
    readonly userId: FieldRef<"RiskAssessment", 'String'>
    readonly riskType: FieldRef<"RiskAssessment", 'String'>
    readonly score: FieldRef<"RiskAssessment", 'Float'>
    readonly confidence: FieldRef<"RiskAssessment", 'Float'>
    readonly factors: FieldRef<"RiskAssessment", 'Json'>
    readonly createdAt: FieldRef<"RiskAssessment", 'DateTime'>
    readonly updatedAt: FieldRef<"RiskAssessment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RiskAssessment findUnique
   */
  export type RiskAssessmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskAssessment
     */
    select?: RiskAssessmentSelect<ExtArgs> | null
    /**
     * Filter, which RiskAssessment to fetch.
     */
    where: RiskAssessmentWhereUniqueInput
  }

  /**
   * RiskAssessment findUniqueOrThrow
   */
  export type RiskAssessmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskAssessment
     */
    select?: RiskAssessmentSelect<ExtArgs> | null
    /**
     * Filter, which RiskAssessment to fetch.
     */
    where: RiskAssessmentWhereUniqueInput
  }

  /**
   * RiskAssessment findFirst
   */
  export type RiskAssessmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskAssessment
     */
    select?: RiskAssessmentSelect<ExtArgs> | null
    /**
     * Filter, which RiskAssessment to fetch.
     */
    where?: RiskAssessmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RiskAssessments to fetch.
     */
    orderBy?: RiskAssessmentOrderByWithRelationInput | RiskAssessmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RiskAssessments.
     */
    cursor?: RiskAssessmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RiskAssessments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RiskAssessments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RiskAssessments.
     */
    distinct?: RiskAssessmentScalarFieldEnum | RiskAssessmentScalarFieldEnum[]
  }

  /**
   * RiskAssessment findFirstOrThrow
   */
  export type RiskAssessmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskAssessment
     */
    select?: RiskAssessmentSelect<ExtArgs> | null
    /**
     * Filter, which RiskAssessment to fetch.
     */
    where?: RiskAssessmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RiskAssessments to fetch.
     */
    orderBy?: RiskAssessmentOrderByWithRelationInput | RiskAssessmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RiskAssessments.
     */
    cursor?: RiskAssessmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RiskAssessments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RiskAssessments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RiskAssessments.
     */
    distinct?: RiskAssessmentScalarFieldEnum | RiskAssessmentScalarFieldEnum[]
  }

  /**
   * RiskAssessment findMany
   */
  export type RiskAssessmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskAssessment
     */
    select?: RiskAssessmentSelect<ExtArgs> | null
    /**
     * Filter, which RiskAssessments to fetch.
     */
    where?: RiskAssessmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RiskAssessments to fetch.
     */
    orderBy?: RiskAssessmentOrderByWithRelationInput | RiskAssessmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RiskAssessments.
     */
    cursor?: RiskAssessmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RiskAssessments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RiskAssessments.
     */
    skip?: number
    distinct?: RiskAssessmentScalarFieldEnum | RiskAssessmentScalarFieldEnum[]
  }

  /**
   * RiskAssessment create
   */
  export type RiskAssessmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskAssessment
     */
    select?: RiskAssessmentSelect<ExtArgs> | null
    /**
     * The data needed to create a RiskAssessment.
     */
    data: XOR<RiskAssessmentCreateInput, RiskAssessmentUncheckedCreateInput>
  }

  /**
   * RiskAssessment createMany
   */
  export type RiskAssessmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RiskAssessments.
     */
    data: RiskAssessmentCreateManyInput | RiskAssessmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RiskAssessment createManyAndReturn
   */
  export type RiskAssessmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskAssessment
     */
    select?: RiskAssessmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RiskAssessments.
     */
    data: RiskAssessmentCreateManyInput | RiskAssessmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RiskAssessment update
   */
  export type RiskAssessmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskAssessment
     */
    select?: RiskAssessmentSelect<ExtArgs> | null
    /**
     * The data needed to update a RiskAssessment.
     */
    data: XOR<RiskAssessmentUpdateInput, RiskAssessmentUncheckedUpdateInput>
    /**
     * Choose, which RiskAssessment to update.
     */
    where: RiskAssessmentWhereUniqueInput
  }

  /**
   * RiskAssessment updateMany
   */
  export type RiskAssessmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RiskAssessments.
     */
    data: XOR<RiskAssessmentUpdateManyMutationInput, RiskAssessmentUncheckedUpdateManyInput>
    /**
     * Filter which RiskAssessments to update
     */
    where?: RiskAssessmentWhereInput
  }

  /**
   * RiskAssessment upsert
   */
  export type RiskAssessmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskAssessment
     */
    select?: RiskAssessmentSelect<ExtArgs> | null
    /**
     * The filter to search for the RiskAssessment to update in case it exists.
     */
    where: RiskAssessmentWhereUniqueInput
    /**
     * In case the RiskAssessment found by the `where` argument doesn't exist, create a new RiskAssessment with this data.
     */
    create: XOR<RiskAssessmentCreateInput, RiskAssessmentUncheckedCreateInput>
    /**
     * In case the RiskAssessment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RiskAssessmentUpdateInput, RiskAssessmentUncheckedUpdateInput>
  }

  /**
   * RiskAssessment delete
   */
  export type RiskAssessmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskAssessment
     */
    select?: RiskAssessmentSelect<ExtArgs> | null
    /**
     * Filter which RiskAssessment to delete.
     */
    where: RiskAssessmentWhereUniqueInput
  }

  /**
   * RiskAssessment deleteMany
   */
  export type RiskAssessmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RiskAssessments to delete
     */
    where?: RiskAssessmentWhereInput
  }

  /**
   * RiskAssessment without action
   */
  export type RiskAssessmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskAssessment
     */
    select?: RiskAssessmentSelect<ExtArgs> | null
  }


  /**
   * Model Recommendation
   */

  export type AggregateRecommendation = {
    _count: RecommendationCountAggregateOutputType | null
    _avg: RecommendationAvgAggregateOutputType | null
    _sum: RecommendationSumAggregateOutputType | null
    _min: RecommendationMinAggregateOutputType | null
    _max: RecommendationMaxAggregateOutputType | null
  }

  export type RecommendationAvgAggregateOutputType = {
    priority: number | null
  }

  export type RecommendationSumAggregateOutputType = {
    priority: number | null
  }

  export type RecommendationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    category: string | null
    priority: number | null
    description: string | null
    rationale: string | null
    references: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RecommendationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    category: string | null
    priority: number | null
    description: string | null
    rationale: string | null
    references: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RecommendationCountAggregateOutputType = {
    id: number
    userId: number
    category: number
    priority: number
    description: number
    rationale: number
    references: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RecommendationAvgAggregateInputType = {
    priority?: true
  }

  export type RecommendationSumAggregateInputType = {
    priority?: true
  }

  export type RecommendationMinAggregateInputType = {
    id?: true
    userId?: true
    category?: true
    priority?: true
    description?: true
    rationale?: true
    references?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RecommendationMaxAggregateInputType = {
    id?: true
    userId?: true
    category?: true
    priority?: true
    description?: true
    rationale?: true
    references?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RecommendationCountAggregateInputType = {
    id?: true
    userId?: true
    category?: true
    priority?: true
    description?: true
    rationale?: true
    references?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RecommendationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Recommendation to aggregate.
     */
    where?: RecommendationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Recommendations to fetch.
     */
    orderBy?: RecommendationOrderByWithRelationInput | RecommendationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RecommendationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Recommendations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Recommendations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Recommendations
    **/
    _count?: true | RecommendationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RecommendationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RecommendationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RecommendationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RecommendationMaxAggregateInputType
  }

  export type GetRecommendationAggregateType<T extends RecommendationAggregateArgs> = {
        [P in keyof T & keyof AggregateRecommendation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRecommendation[P]>
      : GetScalarType<T[P], AggregateRecommendation[P]>
  }




  export type RecommendationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecommendationWhereInput
    orderBy?: RecommendationOrderByWithAggregationInput | RecommendationOrderByWithAggregationInput[]
    by: RecommendationScalarFieldEnum[] | RecommendationScalarFieldEnum
    having?: RecommendationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RecommendationCountAggregateInputType | true
    _avg?: RecommendationAvgAggregateInputType
    _sum?: RecommendationSumAggregateInputType
    _min?: RecommendationMinAggregateInputType
    _max?: RecommendationMaxAggregateInputType
  }

  export type RecommendationGroupByOutputType = {
    id: string
    userId: string
    category: string
    priority: number
    description: string
    rationale: string
    references: string | null
    createdAt: Date
    updatedAt: Date
    _count: RecommendationCountAggregateOutputType | null
    _avg: RecommendationAvgAggregateOutputType | null
    _sum: RecommendationSumAggregateOutputType | null
    _min: RecommendationMinAggregateOutputType | null
    _max: RecommendationMaxAggregateOutputType | null
  }

  type GetRecommendationGroupByPayload<T extends RecommendationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RecommendationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RecommendationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RecommendationGroupByOutputType[P]>
            : GetScalarType<T[P], RecommendationGroupByOutputType[P]>
        }
      >
    >


  export type RecommendationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    category?: boolean
    priority?: boolean
    description?: boolean
    rationale?: boolean
    references?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["recommendation"]>

  export type RecommendationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    category?: boolean
    priority?: boolean
    description?: boolean
    rationale?: boolean
    references?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["recommendation"]>

  export type RecommendationSelectScalar = {
    id?: boolean
    userId?: boolean
    category?: boolean
    priority?: boolean
    description?: boolean
    rationale?: boolean
    references?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $RecommendationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Recommendation"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      category: string
      priority: number
      description: string
      rationale: string
      references: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["recommendation"]>
    composites: {}
  }

  type RecommendationGetPayload<S extends boolean | null | undefined | RecommendationDefaultArgs> = $Result.GetResult<Prisma.$RecommendationPayload, S>

  type RecommendationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RecommendationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RecommendationCountAggregateInputType | true
    }

  export interface RecommendationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Recommendation'], meta: { name: 'Recommendation' } }
    /**
     * Find zero or one Recommendation that matches the filter.
     * @param {RecommendationFindUniqueArgs} args - Arguments to find a Recommendation
     * @example
     * // Get one Recommendation
     * const recommendation = await prisma.recommendation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RecommendationFindUniqueArgs>(args: SelectSubset<T, RecommendationFindUniqueArgs<ExtArgs>>): Prisma__RecommendationClient<$Result.GetResult<Prisma.$RecommendationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Recommendation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RecommendationFindUniqueOrThrowArgs} args - Arguments to find a Recommendation
     * @example
     * // Get one Recommendation
     * const recommendation = await prisma.recommendation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RecommendationFindUniqueOrThrowArgs>(args: SelectSubset<T, RecommendationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RecommendationClient<$Result.GetResult<Prisma.$RecommendationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Recommendation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecommendationFindFirstArgs} args - Arguments to find a Recommendation
     * @example
     * // Get one Recommendation
     * const recommendation = await prisma.recommendation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RecommendationFindFirstArgs>(args?: SelectSubset<T, RecommendationFindFirstArgs<ExtArgs>>): Prisma__RecommendationClient<$Result.GetResult<Prisma.$RecommendationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Recommendation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecommendationFindFirstOrThrowArgs} args - Arguments to find a Recommendation
     * @example
     * // Get one Recommendation
     * const recommendation = await prisma.recommendation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RecommendationFindFirstOrThrowArgs>(args?: SelectSubset<T, RecommendationFindFirstOrThrowArgs<ExtArgs>>): Prisma__RecommendationClient<$Result.GetResult<Prisma.$RecommendationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Recommendations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecommendationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Recommendations
     * const recommendations = await prisma.recommendation.findMany()
     * 
     * // Get first 10 Recommendations
     * const recommendations = await prisma.recommendation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const recommendationWithIdOnly = await prisma.recommendation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RecommendationFindManyArgs>(args?: SelectSubset<T, RecommendationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecommendationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Recommendation.
     * @param {RecommendationCreateArgs} args - Arguments to create a Recommendation.
     * @example
     * // Create one Recommendation
     * const Recommendation = await prisma.recommendation.create({
     *   data: {
     *     // ... data to create a Recommendation
     *   }
     * })
     * 
     */
    create<T extends RecommendationCreateArgs>(args: SelectSubset<T, RecommendationCreateArgs<ExtArgs>>): Prisma__RecommendationClient<$Result.GetResult<Prisma.$RecommendationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Recommendations.
     * @param {RecommendationCreateManyArgs} args - Arguments to create many Recommendations.
     * @example
     * // Create many Recommendations
     * const recommendation = await prisma.recommendation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RecommendationCreateManyArgs>(args?: SelectSubset<T, RecommendationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Recommendations and returns the data saved in the database.
     * @param {RecommendationCreateManyAndReturnArgs} args - Arguments to create many Recommendations.
     * @example
     * // Create many Recommendations
     * const recommendation = await prisma.recommendation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Recommendations and only return the `id`
     * const recommendationWithIdOnly = await prisma.recommendation.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RecommendationCreateManyAndReturnArgs>(args?: SelectSubset<T, RecommendationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecommendationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Recommendation.
     * @param {RecommendationDeleteArgs} args - Arguments to delete one Recommendation.
     * @example
     * // Delete one Recommendation
     * const Recommendation = await prisma.recommendation.delete({
     *   where: {
     *     // ... filter to delete one Recommendation
     *   }
     * })
     * 
     */
    delete<T extends RecommendationDeleteArgs>(args: SelectSubset<T, RecommendationDeleteArgs<ExtArgs>>): Prisma__RecommendationClient<$Result.GetResult<Prisma.$RecommendationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Recommendation.
     * @param {RecommendationUpdateArgs} args - Arguments to update one Recommendation.
     * @example
     * // Update one Recommendation
     * const recommendation = await prisma.recommendation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RecommendationUpdateArgs>(args: SelectSubset<T, RecommendationUpdateArgs<ExtArgs>>): Prisma__RecommendationClient<$Result.GetResult<Prisma.$RecommendationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Recommendations.
     * @param {RecommendationDeleteManyArgs} args - Arguments to filter Recommendations to delete.
     * @example
     * // Delete a few Recommendations
     * const { count } = await prisma.recommendation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RecommendationDeleteManyArgs>(args?: SelectSubset<T, RecommendationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Recommendations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecommendationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Recommendations
     * const recommendation = await prisma.recommendation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RecommendationUpdateManyArgs>(args: SelectSubset<T, RecommendationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Recommendation.
     * @param {RecommendationUpsertArgs} args - Arguments to update or create a Recommendation.
     * @example
     * // Update or create a Recommendation
     * const recommendation = await prisma.recommendation.upsert({
     *   create: {
     *     // ... data to create a Recommendation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Recommendation we want to update
     *   }
     * })
     */
    upsert<T extends RecommendationUpsertArgs>(args: SelectSubset<T, RecommendationUpsertArgs<ExtArgs>>): Prisma__RecommendationClient<$Result.GetResult<Prisma.$RecommendationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Recommendations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecommendationCountArgs} args - Arguments to filter Recommendations to count.
     * @example
     * // Count the number of Recommendations
     * const count = await prisma.recommendation.count({
     *   where: {
     *     // ... the filter for the Recommendations we want to count
     *   }
     * })
    **/
    count<T extends RecommendationCountArgs>(
      args?: Subset<T, RecommendationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RecommendationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Recommendation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecommendationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RecommendationAggregateArgs>(args: Subset<T, RecommendationAggregateArgs>): Prisma.PrismaPromise<GetRecommendationAggregateType<T>>

    /**
     * Group by Recommendation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecommendationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RecommendationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RecommendationGroupByArgs['orderBy'] }
        : { orderBy?: RecommendationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RecommendationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRecommendationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Recommendation model
   */
  readonly fields: RecommendationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Recommendation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RecommendationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Recommendation model
   */ 
  interface RecommendationFieldRefs {
    readonly id: FieldRef<"Recommendation", 'String'>
    readonly userId: FieldRef<"Recommendation", 'String'>
    readonly category: FieldRef<"Recommendation", 'String'>
    readonly priority: FieldRef<"Recommendation", 'Int'>
    readonly description: FieldRef<"Recommendation", 'String'>
    readonly rationale: FieldRef<"Recommendation", 'String'>
    readonly references: FieldRef<"Recommendation", 'String'>
    readonly createdAt: FieldRef<"Recommendation", 'DateTime'>
    readonly updatedAt: FieldRef<"Recommendation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Recommendation findUnique
   */
  export type RecommendationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recommendation
     */
    select?: RecommendationSelect<ExtArgs> | null
    /**
     * Filter, which Recommendation to fetch.
     */
    where: RecommendationWhereUniqueInput
  }

  /**
   * Recommendation findUniqueOrThrow
   */
  export type RecommendationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recommendation
     */
    select?: RecommendationSelect<ExtArgs> | null
    /**
     * Filter, which Recommendation to fetch.
     */
    where: RecommendationWhereUniqueInput
  }

  /**
   * Recommendation findFirst
   */
  export type RecommendationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recommendation
     */
    select?: RecommendationSelect<ExtArgs> | null
    /**
     * Filter, which Recommendation to fetch.
     */
    where?: RecommendationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Recommendations to fetch.
     */
    orderBy?: RecommendationOrderByWithRelationInput | RecommendationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Recommendations.
     */
    cursor?: RecommendationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Recommendations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Recommendations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Recommendations.
     */
    distinct?: RecommendationScalarFieldEnum | RecommendationScalarFieldEnum[]
  }

  /**
   * Recommendation findFirstOrThrow
   */
  export type RecommendationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recommendation
     */
    select?: RecommendationSelect<ExtArgs> | null
    /**
     * Filter, which Recommendation to fetch.
     */
    where?: RecommendationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Recommendations to fetch.
     */
    orderBy?: RecommendationOrderByWithRelationInput | RecommendationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Recommendations.
     */
    cursor?: RecommendationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Recommendations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Recommendations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Recommendations.
     */
    distinct?: RecommendationScalarFieldEnum | RecommendationScalarFieldEnum[]
  }

  /**
   * Recommendation findMany
   */
  export type RecommendationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recommendation
     */
    select?: RecommendationSelect<ExtArgs> | null
    /**
     * Filter, which Recommendations to fetch.
     */
    where?: RecommendationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Recommendations to fetch.
     */
    orderBy?: RecommendationOrderByWithRelationInput | RecommendationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Recommendations.
     */
    cursor?: RecommendationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Recommendations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Recommendations.
     */
    skip?: number
    distinct?: RecommendationScalarFieldEnum | RecommendationScalarFieldEnum[]
  }

  /**
   * Recommendation create
   */
  export type RecommendationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recommendation
     */
    select?: RecommendationSelect<ExtArgs> | null
    /**
     * The data needed to create a Recommendation.
     */
    data: XOR<RecommendationCreateInput, RecommendationUncheckedCreateInput>
  }

  /**
   * Recommendation createMany
   */
  export type RecommendationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Recommendations.
     */
    data: RecommendationCreateManyInput | RecommendationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Recommendation createManyAndReturn
   */
  export type RecommendationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recommendation
     */
    select?: RecommendationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Recommendations.
     */
    data: RecommendationCreateManyInput | RecommendationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Recommendation update
   */
  export type RecommendationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recommendation
     */
    select?: RecommendationSelect<ExtArgs> | null
    /**
     * The data needed to update a Recommendation.
     */
    data: XOR<RecommendationUpdateInput, RecommendationUncheckedUpdateInput>
    /**
     * Choose, which Recommendation to update.
     */
    where: RecommendationWhereUniqueInput
  }

  /**
   * Recommendation updateMany
   */
  export type RecommendationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Recommendations.
     */
    data: XOR<RecommendationUpdateManyMutationInput, RecommendationUncheckedUpdateManyInput>
    /**
     * Filter which Recommendations to update
     */
    where?: RecommendationWhereInput
  }

  /**
   * Recommendation upsert
   */
  export type RecommendationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recommendation
     */
    select?: RecommendationSelect<ExtArgs> | null
    /**
     * The filter to search for the Recommendation to update in case it exists.
     */
    where: RecommendationWhereUniqueInput
    /**
     * In case the Recommendation found by the `where` argument doesn't exist, create a new Recommendation with this data.
     */
    create: XOR<RecommendationCreateInput, RecommendationUncheckedCreateInput>
    /**
     * In case the Recommendation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RecommendationUpdateInput, RecommendationUncheckedUpdateInput>
  }

  /**
   * Recommendation delete
   */
  export type RecommendationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recommendation
     */
    select?: RecommendationSelect<ExtArgs> | null
    /**
     * Filter which Recommendation to delete.
     */
    where: RecommendationWhereUniqueInput
  }

  /**
   * Recommendation deleteMany
   */
  export type RecommendationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Recommendations to delete
     */
    where?: RecommendationWhereInput
  }

  /**
   * Recommendation without action
   */
  export type RecommendationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recommendation
     */
    select?: RecommendationSelect<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    name: 'name',
    dateOfBirth: 'dateOfBirth',
    sex: 'sex',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const HealthReportScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    reportType: 'reportType',
    collectionDate: 'collectionDate',
    provider: 'provider',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type HealthReportScalarFieldEnum = (typeof HealthReportScalarFieldEnum)[keyof typeof HealthReportScalarFieldEnum]


  export const BiomarkerValueScalarFieldEnum: {
    id: 'id',
    healthReportId: 'healthReportId',
    biomarkerId: 'biomarkerId',
    value: 'value',
    unit: 'unit',
    referenceMin: 'referenceMin',
    referenceMax: 'referenceMax',
    isAbnormal: 'isAbnormal',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BiomarkerValueScalarFieldEnum = (typeof BiomarkerValueScalarFieldEnum)[keyof typeof BiomarkerValueScalarFieldEnum]


  export const BiomarkerScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    description: 'description',
    category: 'category',
    unit: 'unit',
    defaultMinRange: 'defaultMinRange',
    defaultMaxRange: 'defaultMaxRange'
  };

  export type BiomarkerScalarFieldEnum = (typeof BiomarkerScalarFieldEnum)[keyof typeof BiomarkerScalarFieldEnum]


  export const SymptomScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    severity: 'severity',
    startDate: 'startDate',
    endDate: 'endDate',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SymptomScalarFieldEnum = (typeof SymptomScalarFieldEnum)[keyof typeof SymptomScalarFieldEnum]


  export const MedicationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    dosage: 'dosage',
    frequency: 'frequency',
    startDate: 'startDate',
    endDate: 'endDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MedicationScalarFieldEnum = (typeof MedicationScalarFieldEnum)[keyof typeof MedicationScalarFieldEnum]


  export const CorrelationScalarFieldEnum: {
    id: 'id',
    biomarkerId: 'biomarkerId',
    symptomId: 'symptomId',
    strength: 'strength',
    direction: 'direction',
    confidence: 'confidence',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CorrelationScalarFieldEnum = (typeof CorrelationScalarFieldEnum)[keyof typeof CorrelationScalarFieldEnum]


  export const RiskAssessmentScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    riskType: 'riskType',
    score: 'score',
    confidence: 'confidence',
    factors: 'factors',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RiskAssessmentScalarFieldEnum = (typeof RiskAssessmentScalarFieldEnum)[keyof typeof RiskAssessmentScalarFieldEnum]


  export const RecommendationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    category: 'category',
    priority: 'priority',
    description: 'description',
    rationale: 'rationale',
    references: 'references',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RecommendationScalarFieldEnum = (typeof RecommendationScalarFieldEnum)[keyof typeof RecommendationScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    dateOfBirth?: DateTimeNullableFilter<"User"> | Date | string | null
    sex?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    healthReports?: HealthReportListRelationFilter
    symptoms?: SymptomListRelationFilter
    medications?: MedicationListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrderInput | SortOrder
    dateOfBirth?: SortOrderInput | SortOrder
    sex?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    healthReports?: HealthReportOrderByRelationAggregateInput
    symptoms?: SymptomOrderByRelationAggregateInput
    medications?: MedicationOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringNullableFilter<"User"> | string | null
    dateOfBirth?: DateTimeNullableFilter<"User"> | Date | string | null
    sex?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    healthReports?: HealthReportListRelationFilter
    symptoms?: SymptomListRelationFilter
    medications?: MedicationListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrderInput | SortOrder
    dateOfBirth?: SortOrderInput | SortOrder
    sex?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    dateOfBirth?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    sex?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type HealthReportWhereInput = {
    AND?: HealthReportWhereInput | HealthReportWhereInput[]
    OR?: HealthReportWhereInput[]
    NOT?: HealthReportWhereInput | HealthReportWhereInput[]
    id?: StringFilter<"HealthReport"> | string
    userId?: StringFilter<"HealthReport"> | string
    reportType?: StringFilter<"HealthReport"> | string
    collectionDate?: DateTimeFilter<"HealthReport"> | Date | string
    provider?: StringNullableFilter<"HealthReport"> | string | null
    notes?: StringNullableFilter<"HealthReport"> | string | null
    createdAt?: DateTimeFilter<"HealthReport"> | Date | string
    updatedAt?: DateTimeFilter<"HealthReport"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    biomarkers?: BiomarkerValueListRelationFilter
  }

  export type HealthReportOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    reportType?: SortOrder
    collectionDate?: SortOrder
    provider?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    biomarkers?: BiomarkerValueOrderByRelationAggregateInput
  }

  export type HealthReportWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: HealthReportWhereInput | HealthReportWhereInput[]
    OR?: HealthReportWhereInput[]
    NOT?: HealthReportWhereInput | HealthReportWhereInput[]
    userId?: StringFilter<"HealthReport"> | string
    reportType?: StringFilter<"HealthReport"> | string
    collectionDate?: DateTimeFilter<"HealthReport"> | Date | string
    provider?: StringNullableFilter<"HealthReport"> | string | null
    notes?: StringNullableFilter<"HealthReport"> | string | null
    createdAt?: DateTimeFilter<"HealthReport"> | Date | string
    updatedAt?: DateTimeFilter<"HealthReport"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    biomarkers?: BiomarkerValueListRelationFilter
  }, "id">

  export type HealthReportOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    reportType?: SortOrder
    collectionDate?: SortOrder
    provider?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: HealthReportCountOrderByAggregateInput
    _max?: HealthReportMaxOrderByAggregateInput
    _min?: HealthReportMinOrderByAggregateInput
  }

  export type HealthReportScalarWhereWithAggregatesInput = {
    AND?: HealthReportScalarWhereWithAggregatesInput | HealthReportScalarWhereWithAggregatesInput[]
    OR?: HealthReportScalarWhereWithAggregatesInput[]
    NOT?: HealthReportScalarWhereWithAggregatesInput | HealthReportScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"HealthReport"> | string
    userId?: StringWithAggregatesFilter<"HealthReport"> | string
    reportType?: StringWithAggregatesFilter<"HealthReport"> | string
    collectionDate?: DateTimeWithAggregatesFilter<"HealthReport"> | Date | string
    provider?: StringNullableWithAggregatesFilter<"HealthReport"> | string | null
    notes?: StringNullableWithAggregatesFilter<"HealthReport"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"HealthReport"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"HealthReport"> | Date | string
  }

  export type BiomarkerValueWhereInput = {
    AND?: BiomarkerValueWhereInput | BiomarkerValueWhereInput[]
    OR?: BiomarkerValueWhereInput[]
    NOT?: BiomarkerValueWhereInput | BiomarkerValueWhereInput[]
    id?: StringFilter<"BiomarkerValue"> | string
    healthReportId?: StringFilter<"BiomarkerValue"> | string
    biomarkerId?: StringFilter<"BiomarkerValue"> | string
    value?: FloatFilter<"BiomarkerValue"> | number
    unit?: StringFilter<"BiomarkerValue"> | string
    referenceMin?: FloatNullableFilter<"BiomarkerValue"> | number | null
    referenceMax?: FloatNullableFilter<"BiomarkerValue"> | number | null
    isAbnormal?: BoolFilter<"BiomarkerValue"> | boolean
    createdAt?: DateTimeFilter<"BiomarkerValue"> | Date | string
    updatedAt?: DateTimeFilter<"BiomarkerValue"> | Date | string
    healthReport?: XOR<HealthReportRelationFilter, HealthReportWhereInput>
    biomarker?: XOR<BiomarkerRelationFilter, BiomarkerWhereInput>
  }

  export type BiomarkerValueOrderByWithRelationInput = {
    id?: SortOrder
    healthReportId?: SortOrder
    biomarkerId?: SortOrder
    value?: SortOrder
    unit?: SortOrder
    referenceMin?: SortOrderInput | SortOrder
    referenceMax?: SortOrderInput | SortOrder
    isAbnormal?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    healthReport?: HealthReportOrderByWithRelationInput
    biomarker?: BiomarkerOrderByWithRelationInput
  }

  export type BiomarkerValueWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BiomarkerValueWhereInput | BiomarkerValueWhereInput[]
    OR?: BiomarkerValueWhereInput[]
    NOT?: BiomarkerValueWhereInput | BiomarkerValueWhereInput[]
    healthReportId?: StringFilter<"BiomarkerValue"> | string
    biomarkerId?: StringFilter<"BiomarkerValue"> | string
    value?: FloatFilter<"BiomarkerValue"> | number
    unit?: StringFilter<"BiomarkerValue"> | string
    referenceMin?: FloatNullableFilter<"BiomarkerValue"> | number | null
    referenceMax?: FloatNullableFilter<"BiomarkerValue"> | number | null
    isAbnormal?: BoolFilter<"BiomarkerValue"> | boolean
    createdAt?: DateTimeFilter<"BiomarkerValue"> | Date | string
    updatedAt?: DateTimeFilter<"BiomarkerValue"> | Date | string
    healthReport?: XOR<HealthReportRelationFilter, HealthReportWhereInput>
    biomarker?: XOR<BiomarkerRelationFilter, BiomarkerWhereInput>
  }, "id">

  export type BiomarkerValueOrderByWithAggregationInput = {
    id?: SortOrder
    healthReportId?: SortOrder
    biomarkerId?: SortOrder
    value?: SortOrder
    unit?: SortOrder
    referenceMin?: SortOrderInput | SortOrder
    referenceMax?: SortOrderInput | SortOrder
    isAbnormal?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BiomarkerValueCountOrderByAggregateInput
    _avg?: BiomarkerValueAvgOrderByAggregateInput
    _max?: BiomarkerValueMaxOrderByAggregateInput
    _min?: BiomarkerValueMinOrderByAggregateInput
    _sum?: BiomarkerValueSumOrderByAggregateInput
  }

  export type BiomarkerValueScalarWhereWithAggregatesInput = {
    AND?: BiomarkerValueScalarWhereWithAggregatesInput | BiomarkerValueScalarWhereWithAggregatesInput[]
    OR?: BiomarkerValueScalarWhereWithAggregatesInput[]
    NOT?: BiomarkerValueScalarWhereWithAggregatesInput | BiomarkerValueScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BiomarkerValue"> | string
    healthReportId?: StringWithAggregatesFilter<"BiomarkerValue"> | string
    biomarkerId?: StringWithAggregatesFilter<"BiomarkerValue"> | string
    value?: FloatWithAggregatesFilter<"BiomarkerValue"> | number
    unit?: StringWithAggregatesFilter<"BiomarkerValue"> | string
    referenceMin?: FloatNullableWithAggregatesFilter<"BiomarkerValue"> | number | null
    referenceMax?: FloatNullableWithAggregatesFilter<"BiomarkerValue"> | number | null
    isAbnormal?: BoolWithAggregatesFilter<"BiomarkerValue"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"BiomarkerValue"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BiomarkerValue"> | Date | string
  }

  export type BiomarkerWhereInput = {
    AND?: BiomarkerWhereInput | BiomarkerWhereInput[]
    OR?: BiomarkerWhereInput[]
    NOT?: BiomarkerWhereInput | BiomarkerWhereInput[]
    id?: StringFilter<"Biomarker"> | string
    code?: StringFilter<"Biomarker"> | string
    name?: StringFilter<"Biomarker"> | string
    description?: StringNullableFilter<"Biomarker"> | string | null
    category?: StringFilter<"Biomarker"> | string
    unit?: StringFilter<"Biomarker"> | string
    defaultMinRange?: FloatNullableFilter<"Biomarker"> | number | null
    defaultMaxRange?: FloatNullableFilter<"Biomarker"> | number | null
    values?: BiomarkerValueListRelationFilter
    correlations?: CorrelationListRelationFilter
  }

  export type BiomarkerOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    unit?: SortOrder
    defaultMinRange?: SortOrderInput | SortOrder
    defaultMaxRange?: SortOrderInput | SortOrder
    values?: BiomarkerValueOrderByRelationAggregateInput
    correlations?: CorrelationOrderByRelationAggregateInput
  }

  export type BiomarkerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: BiomarkerWhereInput | BiomarkerWhereInput[]
    OR?: BiomarkerWhereInput[]
    NOT?: BiomarkerWhereInput | BiomarkerWhereInput[]
    name?: StringFilter<"Biomarker"> | string
    description?: StringNullableFilter<"Biomarker"> | string | null
    category?: StringFilter<"Biomarker"> | string
    unit?: StringFilter<"Biomarker"> | string
    defaultMinRange?: FloatNullableFilter<"Biomarker"> | number | null
    defaultMaxRange?: FloatNullableFilter<"Biomarker"> | number | null
    values?: BiomarkerValueListRelationFilter
    correlations?: CorrelationListRelationFilter
  }, "id" | "code">

  export type BiomarkerOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    unit?: SortOrder
    defaultMinRange?: SortOrderInput | SortOrder
    defaultMaxRange?: SortOrderInput | SortOrder
    _count?: BiomarkerCountOrderByAggregateInput
    _avg?: BiomarkerAvgOrderByAggregateInput
    _max?: BiomarkerMaxOrderByAggregateInput
    _min?: BiomarkerMinOrderByAggregateInput
    _sum?: BiomarkerSumOrderByAggregateInput
  }

  export type BiomarkerScalarWhereWithAggregatesInput = {
    AND?: BiomarkerScalarWhereWithAggregatesInput | BiomarkerScalarWhereWithAggregatesInput[]
    OR?: BiomarkerScalarWhereWithAggregatesInput[]
    NOT?: BiomarkerScalarWhereWithAggregatesInput | BiomarkerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Biomarker"> | string
    code?: StringWithAggregatesFilter<"Biomarker"> | string
    name?: StringWithAggregatesFilter<"Biomarker"> | string
    description?: StringNullableWithAggregatesFilter<"Biomarker"> | string | null
    category?: StringWithAggregatesFilter<"Biomarker"> | string
    unit?: StringWithAggregatesFilter<"Biomarker"> | string
    defaultMinRange?: FloatNullableWithAggregatesFilter<"Biomarker"> | number | null
    defaultMaxRange?: FloatNullableWithAggregatesFilter<"Biomarker"> | number | null
  }

  export type SymptomWhereInput = {
    AND?: SymptomWhereInput | SymptomWhereInput[]
    OR?: SymptomWhereInput[]
    NOT?: SymptomWhereInput | SymptomWhereInput[]
    id?: StringFilter<"Symptom"> | string
    userId?: StringFilter<"Symptom"> | string
    name?: StringFilter<"Symptom"> | string
    severity?: IntFilter<"Symptom"> | number
    startDate?: DateTimeFilter<"Symptom"> | Date | string
    endDate?: DateTimeNullableFilter<"Symptom"> | Date | string | null
    notes?: StringNullableFilter<"Symptom"> | string | null
    createdAt?: DateTimeFilter<"Symptom"> | Date | string
    updatedAt?: DateTimeFilter<"Symptom"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    correlations?: CorrelationListRelationFilter
  }

  export type SymptomOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    severity?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    correlations?: CorrelationOrderByRelationAggregateInput
  }

  export type SymptomWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SymptomWhereInput | SymptomWhereInput[]
    OR?: SymptomWhereInput[]
    NOT?: SymptomWhereInput | SymptomWhereInput[]
    userId?: StringFilter<"Symptom"> | string
    name?: StringFilter<"Symptom"> | string
    severity?: IntFilter<"Symptom"> | number
    startDate?: DateTimeFilter<"Symptom"> | Date | string
    endDate?: DateTimeNullableFilter<"Symptom"> | Date | string | null
    notes?: StringNullableFilter<"Symptom"> | string | null
    createdAt?: DateTimeFilter<"Symptom"> | Date | string
    updatedAt?: DateTimeFilter<"Symptom"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    correlations?: CorrelationListRelationFilter
  }, "id">

  export type SymptomOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    severity?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SymptomCountOrderByAggregateInput
    _avg?: SymptomAvgOrderByAggregateInput
    _max?: SymptomMaxOrderByAggregateInput
    _min?: SymptomMinOrderByAggregateInput
    _sum?: SymptomSumOrderByAggregateInput
  }

  export type SymptomScalarWhereWithAggregatesInput = {
    AND?: SymptomScalarWhereWithAggregatesInput | SymptomScalarWhereWithAggregatesInput[]
    OR?: SymptomScalarWhereWithAggregatesInput[]
    NOT?: SymptomScalarWhereWithAggregatesInput | SymptomScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Symptom"> | string
    userId?: StringWithAggregatesFilter<"Symptom"> | string
    name?: StringWithAggregatesFilter<"Symptom"> | string
    severity?: IntWithAggregatesFilter<"Symptom"> | number
    startDate?: DateTimeWithAggregatesFilter<"Symptom"> | Date | string
    endDate?: DateTimeNullableWithAggregatesFilter<"Symptom"> | Date | string | null
    notes?: StringNullableWithAggregatesFilter<"Symptom"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Symptom"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Symptom"> | Date | string
  }

  export type MedicationWhereInput = {
    AND?: MedicationWhereInput | MedicationWhereInput[]
    OR?: MedicationWhereInput[]
    NOT?: MedicationWhereInput | MedicationWhereInput[]
    id?: StringFilter<"Medication"> | string
    userId?: StringFilter<"Medication"> | string
    name?: StringFilter<"Medication"> | string
    dosage?: StringNullableFilter<"Medication"> | string | null
    frequency?: StringNullableFilter<"Medication"> | string | null
    startDate?: DateTimeFilter<"Medication"> | Date | string
    endDate?: DateTimeNullableFilter<"Medication"> | Date | string | null
    createdAt?: DateTimeFilter<"Medication"> | Date | string
    updatedAt?: DateTimeFilter<"Medication"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type MedicationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    dosage?: SortOrderInput | SortOrder
    frequency?: SortOrderInput | SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type MedicationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MedicationWhereInput | MedicationWhereInput[]
    OR?: MedicationWhereInput[]
    NOT?: MedicationWhereInput | MedicationWhereInput[]
    userId?: StringFilter<"Medication"> | string
    name?: StringFilter<"Medication"> | string
    dosage?: StringNullableFilter<"Medication"> | string | null
    frequency?: StringNullableFilter<"Medication"> | string | null
    startDate?: DateTimeFilter<"Medication"> | Date | string
    endDate?: DateTimeNullableFilter<"Medication"> | Date | string | null
    createdAt?: DateTimeFilter<"Medication"> | Date | string
    updatedAt?: DateTimeFilter<"Medication"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type MedicationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    dosage?: SortOrderInput | SortOrder
    frequency?: SortOrderInput | SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MedicationCountOrderByAggregateInput
    _max?: MedicationMaxOrderByAggregateInput
    _min?: MedicationMinOrderByAggregateInput
  }

  export type MedicationScalarWhereWithAggregatesInput = {
    AND?: MedicationScalarWhereWithAggregatesInput | MedicationScalarWhereWithAggregatesInput[]
    OR?: MedicationScalarWhereWithAggregatesInput[]
    NOT?: MedicationScalarWhereWithAggregatesInput | MedicationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Medication"> | string
    userId?: StringWithAggregatesFilter<"Medication"> | string
    name?: StringWithAggregatesFilter<"Medication"> | string
    dosage?: StringNullableWithAggregatesFilter<"Medication"> | string | null
    frequency?: StringNullableWithAggregatesFilter<"Medication"> | string | null
    startDate?: DateTimeWithAggregatesFilter<"Medication"> | Date | string
    endDate?: DateTimeNullableWithAggregatesFilter<"Medication"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Medication"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Medication"> | Date | string
  }

  export type CorrelationWhereInput = {
    AND?: CorrelationWhereInput | CorrelationWhereInput[]
    OR?: CorrelationWhereInput[]
    NOT?: CorrelationWhereInput | CorrelationWhereInput[]
    id?: StringFilter<"Correlation"> | string
    biomarkerId?: StringFilter<"Correlation"> | string
    symptomId?: StringFilter<"Correlation"> | string
    strength?: FloatFilter<"Correlation"> | number
    direction?: StringFilter<"Correlation"> | string
    confidence?: FloatFilter<"Correlation"> | number
    createdAt?: DateTimeFilter<"Correlation"> | Date | string
    updatedAt?: DateTimeFilter<"Correlation"> | Date | string
    biomarker?: XOR<BiomarkerRelationFilter, BiomarkerWhereInput>
    symptom?: XOR<SymptomRelationFilter, SymptomWhereInput>
  }

  export type CorrelationOrderByWithRelationInput = {
    id?: SortOrder
    biomarkerId?: SortOrder
    symptomId?: SortOrder
    strength?: SortOrder
    direction?: SortOrder
    confidence?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    biomarker?: BiomarkerOrderByWithRelationInput
    symptom?: SymptomOrderByWithRelationInput
  }

  export type CorrelationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CorrelationWhereInput | CorrelationWhereInput[]
    OR?: CorrelationWhereInput[]
    NOT?: CorrelationWhereInput | CorrelationWhereInput[]
    biomarkerId?: StringFilter<"Correlation"> | string
    symptomId?: StringFilter<"Correlation"> | string
    strength?: FloatFilter<"Correlation"> | number
    direction?: StringFilter<"Correlation"> | string
    confidence?: FloatFilter<"Correlation"> | number
    createdAt?: DateTimeFilter<"Correlation"> | Date | string
    updatedAt?: DateTimeFilter<"Correlation"> | Date | string
    biomarker?: XOR<BiomarkerRelationFilter, BiomarkerWhereInput>
    symptom?: XOR<SymptomRelationFilter, SymptomWhereInput>
  }, "id">

  export type CorrelationOrderByWithAggregationInput = {
    id?: SortOrder
    biomarkerId?: SortOrder
    symptomId?: SortOrder
    strength?: SortOrder
    direction?: SortOrder
    confidence?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CorrelationCountOrderByAggregateInput
    _avg?: CorrelationAvgOrderByAggregateInput
    _max?: CorrelationMaxOrderByAggregateInput
    _min?: CorrelationMinOrderByAggregateInput
    _sum?: CorrelationSumOrderByAggregateInput
  }

  export type CorrelationScalarWhereWithAggregatesInput = {
    AND?: CorrelationScalarWhereWithAggregatesInput | CorrelationScalarWhereWithAggregatesInput[]
    OR?: CorrelationScalarWhereWithAggregatesInput[]
    NOT?: CorrelationScalarWhereWithAggregatesInput | CorrelationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Correlation"> | string
    biomarkerId?: StringWithAggregatesFilter<"Correlation"> | string
    symptomId?: StringWithAggregatesFilter<"Correlation"> | string
    strength?: FloatWithAggregatesFilter<"Correlation"> | number
    direction?: StringWithAggregatesFilter<"Correlation"> | string
    confidence?: FloatWithAggregatesFilter<"Correlation"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Correlation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Correlation"> | Date | string
  }

  export type RiskAssessmentWhereInput = {
    AND?: RiskAssessmentWhereInput | RiskAssessmentWhereInput[]
    OR?: RiskAssessmentWhereInput[]
    NOT?: RiskAssessmentWhereInput | RiskAssessmentWhereInput[]
    id?: StringFilter<"RiskAssessment"> | string
    userId?: StringFilter<"RiskAssessment"> | string
    riskType?: StringFilter<"RiskAssessment"> | string
    score?: FloatFilter<"RiskAssessment"> | number
    confidence?: FloatFilter<"RiskAssessment"> | number
    factors?: JsonFilter<"RiskAssessment">
    createdAt?: DateTimeFilter<"RiskAssessment"> | Date | string
    updatedAt?: DateTimeFilter<"RiskAssessment"> | Date | string
  }

  export type RiskAssessmentOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    riskType?: SortOrder
    score?: SortOrder
    confidence?: SortOrder
    factors?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RiskAssessmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RiskAssessmentWhereInput | RiskAssessmentWhereInput[]
    OR?: RiskAssessmentWhereInput[]
    NOT?: RiskAssessmentWhereInput | RiskAssessmentWhereInput[]
    userId?: StringFilter<"RiskAssessment"> | string
    riskType?: StringFilter<"RiskAssessment"> | string
    score?: FloatFilter<"RiskAssessment"> | number
    confidence?: FloatFilter<"RiskAssessment"> | number
    factors?: JsonFilter<"RiskAssessment">
    createdAt?: DateTimeFilter<"RiskAssessment"> | Date | string
    updatedAt?: DateTimeFilter<"RiskAssessment"> | Date | string
  }, "id">

  export type RiskAssessmentOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    riskType?: SortOrder
    score?: SortOrder
    confidence?: SortOrder
    factors?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RiskAssessmentCountOrderByAggregateInput
    _avg?: RiskAssessmentAvgOrderByAggregateInput
    _max?: RiskAssessmentMaxOrderByAggregateInput
    _min?: RiskAssessmentMinOrderByAggregateInput
    _sum?: RiskAssessmentSumOrderByAggregateInput
  }

  export type RiskAssessmentScalarWhereWithAggregatesInput = {
    AND?: RiskAssessmentScalarWhereWithAggregatesInput | RiskAssessmentScalarWhereWithAggregatesInput[]
    OR?: RiskAssessmentScalarWhereWithAggregatesInput[]
    NOT?: RiskAssessmentScalarWhereWithAggregatesInput | RiskAssessmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RiskAssessment"> | string
    userId?: StringWithAggregatesFilter<"RiskAssessment"> | string
    riskType?: StringWithAggregatesFilter<"RiskAssessment"> | string
    score?: FloatWithAggregatesFilter<"RiskAssessment"> | number
    confidence?: FloatWithAggregatesFilter<"RiskAssessment"> | number
    factors?: JsonWithAggregatesFilter<"RiskAssessment">
    createdAt?: DateTimeWithAggregatesFilter<"RiskAssessment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RiskAssessment"> | Date | string
  }

  export type RecommendationWhereInput = {
    AND?: RecommendationWhereInput | RecommendationWhereInput[]
    OR?: RecommendationWhereInput[]
    NOT?: RecommendationWhereInput | RecommendationWhereInput[]
    id?: StringFilter<"Recommendation"> | string
    userId?: StringFilter<"Recommendation"> | string
    category?: StringFilter<"Recommendation"> | string
    priority?: IntFilter<"Recommendation"> | number
    description?: StringFilter<"Recommendation"> | string
    rationale?: StringFilter<"Recommendation"> | string
    references?: StringNullableFilter<"Recommendation"> | string | null
    createdAt?: DateTimeFilter<"Recommendation"> | Date | string
    updatedAt?: DateTimeFilter<"Recommendation"> | Date | string
  }

  export type RecommendationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    category?: SortOrder
    priority?: SortOrder
    description?: SortOrder
    rationale?: SortOrder
    references?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RecommendationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RecommendationWhereInput | RecommendationWhereInput[]
    OR?: RecommendationWhereInput[]
    NOT?: RecommendationWhereInput | RecommendationWhereInput[]
    userId?: StringFilter<"Recommendation"> | string
    category?: StringFilter<"Recommendation"> | string
    priority?: IntFilter<"Recommendation"> | number
    description?: StringFilter<"Recommendation"> | string
    rationale?: StringFilter<"Recommendation"> | string
    references?: StringNullableFilter<"Recommendation"> | string | null
    createdAt?: DateTimeFilter<"Recommendation"> | Date | string
    updatedAt?: DateTimeFilter<"Recommendation"> | Date | string
  }, "id">

  export type RecommendationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    category?: SortOrder
    priority?: SortOrder
    description?: SortOrder
    rationale?: SortOrder
    references?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RecommendationCountOrderByAggregateInput
    _avg?: RecommendationAvgOrderByAggregateInput
    _max?: RecommendationMaxOrderByAggregateInput
    _min?: RecommendationMinOrderByAggregateInput
    _sum?: RecommendationSumOrderByAggregateInput
  }

  export type RecommendationScalarWhereWithAggregatesInput = {
    AND?: RecommendationScalarWhereWithAggregatesInput | RecommendationScalarWhereWithAggregatesInput[]
    OR?: RecommendationScalarWhereWithAggregatesInput[]
    NOT?: RecommendationScalarWhereWithAggregatesInput | RecommendationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Recommendation"> | string
    userId?: StringWithAggregatesFilter<"Recommendation"> | string
    category?: StringWithAggregatesFilter<"Recommendation"> | string
    priority?: IntWithAggregatesFilter<"Recommendation"> | number
    description?: StringWithAggregatesFilter<"Recommendation"> | string
    rationale?: StringWithAggregatesFilter<"Recommendation"> | string
    references?: StringNullableWithAggregatesFilter<"Recommendation"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Recommendation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Recommendation"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    name?: string | null
    dateOfBirth?: Date | string | null
    sex?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    healthReports?: HealthReportCreateNestedManyWithoutUserInput
    symptoms?: SymptomCreateNestedManyWithoutUserInput
    medications?: MedicationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    name?: string | null
    dateOfBirth?: Date | string | null
    sex?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    healthReports?: HealthReportUncheckedCreateNestedManyWithoutUserInput
    symptoms?: SymptomUncheckedCreateNestedManyWithoutUserInput
    medications?: MedicationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    healthReports?: HealthReportUpdateManyWithoutUserNestedInput
    symptoms?: SymptomUpdateManyWithoutUserNestedInput
    medications?: MedicationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    healthReports?: HealthReportUncheckedUpdateManyWithoutUserNestedInput
    symptoms?: SymptomUncheckedUpdateManyWithoutUserNestedInput
    medications?: MedicationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    name?: string | null
    dateOfBirth?: Date | string | null
    sex?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HealthReportCreateInput = {
    id?: string
    reportType: string
    collectionDate: Date | string
    provider?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutHealthReportsInput
    biomarkers?: BiomarkerValueCreateNestedManyWithoutHealthReportInput
  }

  export type HealthReportUncheckedCreateInput = {
    id?: string
    userId: string
    reportType: string
    collectionDate: Date | string
    provider?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    biomarkers?: BiomarkerValueUncheckedCreateNestedManyWithoutHealthReportInput
  }

  export type HealthReportUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reportType?: StringFieldUpdateOperationsInput | string
    collectionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutHealthReportsNestedInput
    biomarkers?: BiomarkerValueUpdateManyWithoutHealthReportNestedInput
  }

  export type HealthReportUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    reportType?: StringFieldUpdateOperationsInput | string
    collectionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    biomarkers?: BiomarkerValueUncheckedUpdateManyWithoutHealthReportNestedInput
  }

  export type HealthReportCreateManyInput = {
    id?: string
    userId: string
    reportType: string
    collectionDate: Date | string
    provider?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HealthReportUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    reportType?: StringFieldUpdateOperationsInput | string
    collectionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HealthReportUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    reportType?: StringFieldUpdateOperationsInput | string
    collectionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BiomarkerValueCreateInput = {
    id?: string
    value: number
    unit: string
    referenceMin?: number | null
    referenceMax?: number | null
    isAbnormal?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    healthReport: HealthReportCreateNestedOneWithoutBiomarkersInput
    biomarker: BiomarkerCreateNestedOneWithoutValuesInput
  }

  export type BiomarkerValueUncheckedCreateInput = {
    id?: string
    healthReportId: string
    biomarkerId: string
    value: number
    unit: string
    referenceMin?: number | null
    referenceMax?: number | null
    isAbnormal?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BiomarkerValueUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    referenceMin?: NullableFloatFieldUpdateOperationsInput | number | null
    referenceMax?: NullableFloatFieldUpdateOperationsInput | number | null
    isAbnormal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    healthReport?: HealthReportUpdateOneRequiredWithoutBiomarkersNestedInput
    biomarker?: BiomarkerUpdateOneRequiredWithoutValuesNestedInput
  }

  export type BiomarkerValueUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    healthReportId?: StringFieldUpdateOperationsInput | string
    biomarkerId?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    referenceMin?: NullableFloatFieldUpdateOperationsInput | number | null
    referenceMax?: NullableFloatFieldUpdateOperationsInput | number | null
    isAbnormal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BiomarkerValueCreateManyInput = {
    id?: string
    healthReportId: string
    biomarkerId: string
    value: number
    unit: string
    referenceMin?: number | null
    referenceMax?: number | null
    isAbnormal?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BiomarkerValueUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    referenceMin?: NullableFloatFieldUpdateOperationsInput | number | null
    referenceMax?: NullableFloatFieldUpdateOperationsInput | number | null
    isAbnormal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BiomarkerValueUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    healthReportId?: StringFieldUpdateOperationsInput | string
    biomarkerId?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    referenceMin?: NullableFloatFieldUpdateOperationsInput | number | null
    referenceMax?: NullableFloatFieldUpdateOperationsInput | number | null
    isAbnormal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BiomarkerCreateInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    category: string
    unit: string
    defaultMinRange?: number | null
    defaultMaxRange?: number | null
    values?: BiomarkerValueCreateNestedManyWithoutBiomarkerInput
    correlations?: CorrelationCreateNestedManyWithoutBiomarkerInput
  }

  export type BiomarkerUncheckedCreateInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    category: string
    unit: string
    defaultMinRange?: number | null
    defaultMaxRange?: number | null
    values?: BiomarkerValueUncheckedCreateNestedManyWithoutBiomarkerInput
    correlations?: CorrelationUncheckedCreateNestedManyWithoutBiomarkerInput
  }

  export type BiomarkerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    defaultMinRange?: NullableFloatFieldUpdateOperationsInput | number | null
    defaultMaxRange?: NullableFloatFieldUpdateOperationsInput | number | null
    values?: BiomarkerValueUpdateManyWithoutBiomarkerNestedInput
    correlations?: CorrelationUpdateManyWithoutBiomarkerNestedInput
  }

  export type BiomarkerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    defaultMinRange?: NullableFloatFieldUpdateOperationsInput | number | null
    defaultMaxRange?: NullableFloatFieldUpdateOperationsInput | number | null
    values?: BiomarkerValueUncheckedUpdateManyWithoutBiomarkerNestedInput
    correlations?: CorrelationUncheckedUpdateManyWithoutBiomarkerNestedInput
  }

  export type BiomarkerCreateManyInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    category: string
    unit: string
    defaultMinRange?: number | null
    defaultMaxRange?: number | null
  }

  export type BiomarkerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    defaultMinRange?: NullableFloatFieldUpdateOperationsInput | number | null
    defaultMaxRange?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type BiomarkerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    defaultMinRange?: NullableFloatFieldUpdateOperationsInput | number | null
    defaultMaxRange?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type SymptomCreateInput = {
    id?: string
    name: string
    severity: number
    startDate: Date | string
    endDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSymptomsInput
    correlations?: CorrelationCreateNestedManyWithoutSymptomInput
  }

  export type SymptomUncheckedCreateInput = {
    id?: string
    userId: string
    name: string
    severity: number
    startDate: Date | string
    endDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    correlations?: CorrelationUncheckedCreateNestedManyWithoutSymptomInput
  }

  export type SymptomUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    severity?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSymptomsNestedInput
    correlations?: CorrelationUpdateManyWithoutSymptomNestedInput
  }

  export type SymptomUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    severity?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    correlations?: CorrelationUncheckedUpdateManyWithoutSymptomNestedInput
  }

  export type SymptomCreateManyInput = {
    id?: string
    userId: string
    name: string
    severity: number
    startDate: Date | string
    endDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SymptomUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    severity?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SymptomUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    severity?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicationCreateInput = {
    id?: string
    name: string
    dosage?: string | null
    frequency?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutMedicationsInput
  }

  export type MedicationUncheckedCreateInput = {
    id?: string
    userId: string
    name: string
    dosage?: string | null
    frequency?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MedicationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    dosage?: NullableStringFieldUpdateOperationsInput | string | null
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMedicationsNestedInput
  }

  export type MedicationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    dosage?: NullableStringFieldUpdateOperationsInput | string | null
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicationCreateManyInput = {
    id?: string
    userId: string
    name: string
    dosage?: string | null
    frequency?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MedicationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    dosage?: NullableStringFieldUpdateOperationsInput | string | null
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    dosage?: NullableStringFieldUpdateOperationsInput | string | null
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CorrelationCreateInput = {
    id?: string
    strength: number
    direction: string
    confidence: number
    createdAt?: Date | string
    updatedAt?: Date | string
    biomarker: BiomarkerCreateNestedOneWithoutCorrelationsInput
    symptom: SymptomCreateNestedOneWithoutCorrelationsInput
  }

  export type CorrelationUncheckedCreateInput = {
    id?: string
    biomarkerId: string
    symptomId: string
    strength: number
    direction: string
    confidence: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CorrelationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    strength?: FloatFieldUpdateOperationsInput | number
    direction?: StringFieldUpdateOperationsInput | string
    confidence?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    biomarker?: BiomarkerUpdateOneRequiredWithoutCorrelationsNestedInput
    symptom?: SymptomUpdateOneRequiredWithoutCorrelationsNestedInput
  }

  export type CorrelationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    biomarkerId?: StringFieldUpdateOperationsInput | string
    symptomId?: StringFieldUpdateOperationsInput | string
    strength?: FloatFieldUpdateOperationsInput | number
    direction?: StringFieldUpdateOperationsInput | string
    confidence?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CorrelationCreateManyInput = {
    id?: string
    biomarkerId: string
    symptomId: string
    strength: number
    direction: string
    confidence: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CorrelationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    strength?: FloatFieldUpdateOperationsInput | number
    direction?: StringFieldUpdateOperationsInput | string
    confidence?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CorrelationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    biomarkerId?: StringFieldUpdateOperationsInput | string
    symptomId?: StringFieldUpdateOperationsInput | string
    strength?: FloatFieldUpdateOperationsInput | number
    direction?: StringFieldUpdateOperationsInput | string
    confidence?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RiskAssessmentCreateInput = {
    id?: string
    userId: string
    riskType: string
    score: number
    confidence: number
    factors: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RiskAssessmentUncheckedCreateInput = {
    id?: string
    userId: string
    riskType: string
    score: number
    confidence: number
    factors: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RiskAssessmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    riskType?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    confidence?: FloatFieldUpdateOperationsInput | number
    factors?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RiskAssessmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    riskType?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    confidence?: FloatFieldUpdateOperationsInput | number
    factors?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RiskAssessmentCreateManyInput = {
    id?: string
    userId: string
    riskType: string
    score: number
    confidence: number
    factors: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RiskAssessmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    riskType?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    confidence?: FloatFieldUpdateOperationsInput | number
    factors?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RiskAssessmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    riskType?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    confidence?: FloatFieldUpdateOperationsInput | number
    factors?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecommendationCreateInput = {
    id?: string
    userId: string
    category: string
    priority: number
    description: string
    rationale: string
    references?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RecommendationUncheckedCreateInput = {
    id?: string
    userId: string
    category: string
    priority: number
    description: string
    rationale: string
    references?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RecommendationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    rationale?: StringFieldUpdateOperationsInput | string
    references?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecommendationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    rationale?: StringFieldUpdateOperationsInput | string
    references?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecommendationCreateManyInput = {
    id?: string
    userId: string
    category: string
    priority: number
    description: string
    rationale: string
    references?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RecommendationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    rationale?: StringFieldUpdateOperationsInput | string
    references?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecommendationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    rationale?: StringFieldUpdateOperationsInput | string
    references?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type HealthReportListRelationFilter = {
    every?: HealthReportWhereInput
    some?: HealthReportWhereInput
    none?: HealthReportWhereInput
  }

  export type SymptomListRelationFilter = {
    every?: SymptomWhereInput
    some?: SymptomWhereInput
    none?: SymptomWhereInput
  }

  export type MedicationListRelationFilter = {
    every?: MedicationWhereInput
    some?: MedicationWhereInput
    none?: MedicationWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type HealthReportOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SymptomOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MedicationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    dateOfBirth?: SortOrder
    sex?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    dateOfBirth?: SortOrder
    sex?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    dateOfBirth?: SortOrder
    sex?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type BiomarkerValueListRelationFilter = {
    every?: BiomarkerValueWhereInput
    some?: BiomarkerValueWhereInput
    none?: BiomarkerValueWhereInput
  }

  export type BiomarkerValueOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HealthReportCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    reportType?: SortOrder
    collectionDate?: SortOrder
    provider?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HealthReportMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    reportType?: SortOrder
    collectionDate?: SortOrder
    provider?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HealthReportMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    reportType?: SortOrder
    collectionDate?: SortOrder
    provider?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type HealthReportRelationFilter = {
    is?: HealthReportWhereInput
    isNot?: HealthReportWhereInput
  }

  export type BiomarkerRelationFilter = {
    is?: BiomarkerWhereInput
    isNot?: BiomarkerWhereInput
  }

  export type BiomarkerValueCountOrderByAggregateInput = {
    id?: SortOrder
    healthReportId?: SortOrder
    biomarkerId?: SortOrder
    value?: SortOrder
    unit?: SortOrder
    referenceMin?: SortOrder
    referenceMax?: SortOrder
    isAbnormal?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BiomarkerValueAvgOrderByAggregateInput = {
    value?: SortOrder
    referenceMin?: SortOrder
    referenceMax?: SortOrder
  }

  export type BiomarkerValueMaxOrderByAggregateInput = {
    id?: SortOrder
    healthReportId?: SortOrder
    biomarkerId?: SortOrder
    value?: SortOrder
    unit?: SortOrder
    referenceMin?: SortOrder
    referenceMax?: SortOrder
    isAbnormal?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BiomarkerValueMinOrderByAggregateInput = {
    id?: SortOrder
    healthReportId?: SortOrder
    biomarkerId?: SortOrder
    value?: SortOrder
    unit?: SortOrder
    referenceMin?: SortOrder
    referenceMax?: SortOrder
    isAbnormal?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BiomarkerValueSumOrderByAggregateInput = {
    value?: SortOrder
    referenceMin?: SortOrder
    referenceMax?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type CorrelationListRelationFilter = {
    every?: CorrelationWhereInput
    some?: CorrelationWhereInput
    none?: CorrelationWhereInput
  }

  export type CorrelationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BiomarkerCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    unit?: SortOrder
    defaultMinRange?: SortOrder
    defaultMaxRange?: SortOrder
  }

  export type BiomarkerAvgOrderByAggregateInput = {
    defaultMinRange?: SortOrder
    defaultMaxRange?: SortOrder
  }

  export type BiomarkerMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    unit?: SortOrder
    defaultMinRange?: SortOrder
    defaultMaxRange?: SortOrder
  }

  export type BiomarkerMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    unit?: SortOrder
    defaultMinRange?: SortOrder
    defaultMaxRange?: SortOrder
  }

  export type BiomarkerSumOrderByAggregateInput = {
    defaultMinRange?: SortOrder
    defaultMaxRange?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type SymptomCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    severity?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SymptomAvgOrderByAggregateInput = {
    severity?: SortOrder
  }

  export type SymptomMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    severity?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SymptomMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    severity?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SymptomSumOrderByAggregateInput = {
    severity?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type MedicationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    dosage?: SortOrder
    frequency?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MedicationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    dosage?: SortOrder
    frequency?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MedicationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    dosage?: SortOrder
    frequency?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SymptomRelationFilter = {
    is?: SymptomWhereInput
    isNot?: SymptomWhereInput
  }

  export type CorrelationCountOrderByAggregateInput = {
    id?: SortOrder
    biomarkerId?: SortOrder
    symptomId?: SortOrder
    strength?: SortOrder
    direction?: SortOrder
    confidence?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CorrelationAvgOrderByAggregateInput = {
    strength?: SortOrder
    confidence?: SortOrder
  }

  export type CorrelationMaxOrderByAggregateInput = {
    id?: SortOrder
    biomarkerId?: SortOrder
    symptomId?: SortOrder
    strength?: SortOrder
    direction?: SortOrder
    confidence?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CorrelationMinOrderByAggregateInput = {
    id?: SortOrder
    biomarkerId?: SortOrder
    symptomId?: SortOrder
    strength?: SortOrder
    direction?: SortOrder
    confidence?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CorrelationSumOrderByAggregateInput = {
    strength?: SortOrder
    confidence?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type RiskAssessmentCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    riskType?: SortOrder
    score?: SortOrder
    confidence?: SortOrder
    factors?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RiskAssessmentAvgOrderByAggregateInput = {
    score?: SortOrder
    confidence?: SortOrder
  }

  export type RiskAssessmentMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    riskType?: SortOrder
    score?: SortOrder
    confidence?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RiskAssessmentMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    riskType?: SortOrder
    score?: SortOrder
    confidence?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RiskAssessmentSumOrderByAggregateInput = {
    score?: SortOrder
    confidence?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type RecommendationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    category?: SortOrder
    priority?: SortOrder
    description?: SortOrder
    rationale?: SortOrder
    references?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RecommendationAvgOrderByAggregateInput = {
    priority?: SortOrder
  }

  export type RecommendationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    category?: SortOrder
    priority?: SortOrder
    description?: SortOrder
    rationale?: SortOrder
    references?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RecommendationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    category?: SortOrder
    priority?: SortOrder
    description?: SortOrder
    rationale?: SortOrder
    references?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RecommendationSumOrderByAggregateInput = {
    priority?: SortOrder
  }

  export type HealthReportCreateNestedManyWithoutUserInput = {
    create?: XOR<HealthReportCreateWithoutUserInput, HealthReportUncheckedCreateWithoutUserInput> | HealthReportCreateWithoutUserInput[] | HealthReportUncheckedCreateWithoutUserInput[]
    connectOrCreate?: HealthReportCreateOrConnectWithoutUserInput | HealthReportCreateOrConnectWithoutUserInput[]
    createMany?: HealthReportCreateManyUserInputEnvelope
    connect?: HealthReportWhereUniqueInput | HealthReportWhereUniqueInput[]
  }

  export type SymptomCreateNestedManyWithoutUserInput = {
    create?: XOR<SymptomCreateWithoutUserInput, SymptomUncheckedCreateWithoutUserInput> | SymptomCreateWithoutUserInput[] | SymptomUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SymptomCreateOrConnectWithoutUserInput | SymptomCreateOrConnectWithoutUserInput[]
    createMany?: SymptomCreateManyUserInputEnvelope
    connect?: SymptomWhereUniqueInput | SymptomWhereUniqueInput[]
  }

  export type MedicationCreateNestedManyWithoutUserInput = {
    create?: XOR<MedicationCreateWithoutUserInput, MedicationUncheckedCreateWithoutUserInput> | MedicationCreateWithoutUserInput[] | MedicationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MedicationCreateOrConnectWithoutUserInput | MedicationCreateOrConnectWithoutUserInput[]
    createMany?: MedicationCreateManyUserInputEnvelope
    connect?: MedicationWhereUniqueInput | MedicationWhereUniqueInput[]
  }

  export type HealthReportUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<HealthReportCreateWithoutUserInput, HealthReportUncheckedCreateWithoutUserInput> | HealthReportCreateWithoutUserInput[] | HealthReportUncheckedCreateWithoutUserInput[]
    connectOrCreate?: HealthReportCreateOrConnectWithoutUserInput | HealthReportCreateOrConnectWithoutUserInput[]
    createMany?: HealthReportCreateManyUserInputEnvelope
    connect?: HealthReportWhereUniqueInput | HealthReportWhereUniqueInput[]
  }

  export type SymptomUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SymptomCreateWithoutUserInput, SymptomUncheckedCreateWithoutUserInput> | SymptomCreateWithoutUserInput[] | SymptomUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SymptomCreateOrConnectWithoutUserInput | SymptomCreateOrConnectWithoutUserInput[]
    createMany?: SymptomCreateManyUserInputEnvelope
    connect?: SymptomWhereUniqueInput | SymptomWhereUniqueInput[]
  }

  export type MedicationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<MedicationCreateWithoutUserInput, MedicationUncheckedCreateWithoutUserInput> | MedicationCreateWithoutUserInput[] | MedicationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MedicationCreateOrConnectWithoutUserInput | MedicationCreateOrConnectWithoutUserInput[]
    createMany?: MedicationCreateManyUserInputEnvelope
    connect?: MedicationWhereUniqueInput | MedicationWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type HealthReportUpdateManyWithoutUserNestedInput = {
    create?: XOR<HealthReportCreateWithoutUserInput, HealthReportUncheckedCreateWithoutUserInput> | HealthReportCreateWithoutUserInput[] | HealthReportUncheckedCreateWithoutUserInput[]
    connectOrCreate?: HealthReportCreateOrConnectWithoutUserInput | HealthReportCreateOrConnectWithoutUserInput[]
    upsert?: HealthReportUpsertWithWhereUniqueWithoutUserInput | HealthReportUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: HealthReportCreateManyUserInputEnvelope
    set?: HealthReportWhereUniqueInput | HealthReportWhereUniqueInput[]
    disconnect?: HealthReportWhereUniqueInput | HealthReportWhereUniqueInput[]
    delete?: HealthReportWhereUniqueInput | HealthReportWhereUniqueInput[]
    connect?: HealthReportWhereUniqueInput | HealthReportWhereUniqueInput[]
    update?: HealthReportUpdateWithWhereUniqueWithoutUserInput | HealthReportUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: HealthReportUpdateManyWithWhereWithoutUserInput | HealthReportUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: HealthReportScalarWhereInput | HealthReportScalarWhereInput[]
  }

  export type SymptomUpdateManyWithoutUserNestedInput = {
    create?: XOR<SymptomCreateWithoutUserInput, SymptomUncheckedCreateWithoutUserInput> | SymptomCreateWithoutUserInput[] | SymptomUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SymptomCreateOrConnectWithoutUserInput | SymptomCreateOrConnectWithoutUserInput[]
    upsert?: SymptomUpsertWithWhereUniqueWithoutUserInput | SymptomUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SymptomCreateManyUserInputEnvelope
    set?: SymptomWhereUniqueInput | SymptomWhereUniqueInput[]
    disconnect?: SymptomWhereUniqueInput | SymptomWhereUniqueInput[]
    delete?: SymptomWhereUniqueInput | SymptomWhereUniqueInput[]
    connect?: SymptomWhereUniqueInput | SymptomWhereUniqueInput[]
    update?: SymptomUpdateWithWhereUniqueWithoutUserInput | SymptomUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SymptomUpdateManyWithWhereWithoutUserInput | SymptomUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SymptomScalarWhereInput | SymptomScalarWhereInput[]
  }

  export type MedicationUpdateManyWithoutUserNestedInput = {
    create?: XOR<MedicationCreateWithoutUserInput, MedicationUncheckedCreateWithoutUserInput> | MedicationCreateWithoutUserInput[] | MedicationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MedicationCreateOrConnectWithoutUserInput | MedicationCreateOrConnectWithoutUserInput[]
    upsert?: MedicationUpsertWithWhereUniqueWithoutUserInput | MedicationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MedicationCreateManyUserInputEnvelope
    set?: MedicationWhereUniqueInput | MedicationWhereUniqueInput[]
    disconnect?: MedicationWhereUniqueInput | MedicationWhereUniqueInput[]
    delete?: MedicationWhereUniqueInput | MedicationWhereUniqueInput[]
    connect?: MedicationWhereUniqueInput | MedicationWhereUniqueInput[]
    update?: MedicationUpdateWithWhereUniqueWithoutUserInput | MedicationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MedicationUpdateManyWithWhereWithoutUserInput | MedicationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MedicationScalarWhereInput | MedicationScalarWhereInput[]
  }

  export type HealthReportUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<HealthReportCreateWithoutUserInput, HealthReportUncheckedCreateWithoutUserInput> | HealthReportCreateWithoutUserInput[] | HealthReportUncheckedCreateWithoutUserInput[]
    connectOrCreate?: HealthReportCreateOrConnectWithoutUserInput | HealthReportCreateOrConnectWithoutUserInput[]
    upsert?: HealthReportUpsertWithWhereUniqueWithoutUserInput | HealthReportUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: HealthReportCreateManyUserInputEnvelope
    set?: HealthReportWhereUniqueInput | HealthReportWhereUniqueInput[]
    disconnect?: HealthReportWhereUniqueInput | HealthReportWhereUniqueInput[]
    delete?: HealthReportWhereUniqueInput | HealthReportWhereUniqueInput[]
    connect?: HealthReportWhereUniqueInput | HealthReportWhereUniqueInput[]
    update?: HealthReportUpdateWithWhereUniqueWithoutUserInput | HealthReportUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: HealthReportUpdateManyWithWhereWithoutUserInput | HealthReportUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: HealthReportScalarWhereInput | HealthReportScalarWhereInput[]
  }

  export type SymptomUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SymptomCreateWithoutUserInput, SymptomUncheckedCreateWithoutUserInput> | SymptomCreateWithoutUserInput[] | SymptomUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SymptomCreateOrConnectWithoutUserInput | SymptomCreateOrConnectWithoutUserInput[]
    upsert?: SymptomUpsertWithWhereUniqueWithoutUserInput | SymptomUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SymptomCreateManyUserInputEnvelope
    set?: SymptomWhereUniqueInput | SymptomWhereUniqueInput[]
    disconnect?: SymptomWhereUniqueInput | SymptomWhereUniqueInput[]
    delete?: SymptomWhereUniqueInput | SymptomWhereUniqueInput[]
    connect?: SymptomWhereUniqueInput | SymptomWhereUniqueInput[]
    update?: SymptomUpdateWithWhereUniqueWithoutUserInput | SymptomUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SymptomUpdateManyWithWhereWithoutUserInput | SymptomUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SymptomScalarWhereInput | SymptomScalarWhereInput[]
  }

  export type MedicationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<MedicationCreateWithoutUserInput, MedicationUncheckedCreateWithoutUserInput> | MedicationCreateWithoutUserInput[] | MedicationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MedicationCreateOrConnectWithoutUserInput | MedicationCreateOrConnectWithoutUserInput[]
    upsert?: MedicationUpsertWithWhereUniqueWithoutUserInput | MedicationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MedicationCreateManyUserInputEnvelope
    set?: MedicationWhereUniqueInput | MedicationWhereUniqueInput[]
    disconnect?: MedicationWhereUniqueInput | MedicationWhereUniqueInput[]
    delete?: MedicationWhereUniqueInput | MedicationWhereUniqueInput[]
    connect?: MedicationWhereUniqueInput | MedicationWhereUniqueInput[]
    update?: MedicationUpdateWithWhereUniqueWithoutUserInput | MedicationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MedicationUpdateManyWithWhereWithoutUserInput | MedicationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MedicationScalarWhereInput | MedicationScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutHealthReportsInput = {
    create?: XOR<UserCreateWithoutHealthReportsInput, UserUncheckedCreateWithoutHealthReportsInput>
    connectOrCreate?: UserCreateOrConnectWithoutHealthReportsInput
    connect?: UserWhereUniqueInput
  }

  export type BiomarkerValueCreateNestedManyWithoutHealthReportInput = {
    create?: XOR<BiomarkerValueCreateWithoutHealthReportInput, BiomarkerValueUncheckedCreateWithoutHealthReportInput> | BiomarkerValueCreateWithoutHealthReportInput[] | BiomarkerValueUncheckedCreateWithoutHealthReportInput[]
    connectOrCreate?: BiomarkerValueCreateOrConnectWithoutHealthReportInput | BiomarkerValueCreateOrConnectWithoutHealthReportInput[]
    createMany?: BiomarkerValueCreateManyHealthReportInputEnvelope
    connect?: BiomarkerValueWhereUniqueInput | BiomarkerValueWhereUniqueInput[]
  }

  export type BiomarkerValueUncheckedCreateNestedManyWithoutHealthReportInput = {
    create?: XOR<BiomarkerValueCreateWithoutHealthReportInput, BiomarkerValueUncheckedCreateWithoutHealthReportInput> | BiomarkerValueCreateWithoutHealthReportInput[] | BiomarkerValueUncheckedCreateWithoutHealthReportInput[]
    connectOrCreate?: BiomarkerValueCreateOrConnectWithoutHealthReportInput | BiomarkerValueCreateOrConnectWithoutHealthReportInput[]
    createMany?: BiomarkerValueCreateManyHealthReportInputEnvelope
    connect?: BiomarkerValueWhereUniqueInput | BiomarkerValueWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutHealthReportsNestedInput = {
    create?: XOR<UserCreateWithoutHealthReportsInput, UserUncheckedCreateWithoutHealthReportsInput>
    connectOrCreate?: UserCreateOrConnectWithoutHealthReportsInput
    upsert?: UserUpsertWithoutHealthReportsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutHealthReportsInput, UserUpdateWithoutHealthReportsInput>, UserUncheckedUpdateWithoutHealthReportsInput>
  }

  export type BiomarkerValueUpdateManyWithoutHealthReportNestedInput = {
    create?: XOR<BiomarkerValueCreateWithoutHealthReportInput, BiomarkerValueUncheckedCreateWithoutHealthReportInput> | BiomarkerValueCreateWithoutHealthReportInput[] | BiomarkerValueUncheckedCreateWithoutHealthReportInput[]
    connectOrCreate?: BiomarkerValueCreateOrConnectWithoutHealthReportInput | BiomarkerValueCreateOrConnectWithoutHealthReportInput[]
    upsert?: BiomarkerValueUpsertWithWhereUniqueWithoutHealthReportInput | BiomarkerValueUpsertWithWhereUniqueWithoutHealthReportInput[]
    createMany?: BiomarkerValueCreateManyHealthReportInputEnvelope
    set?: BiomarkerValueWhereUniqueInput | BiomarkerValueWhereUniqueInput[]
    disconnect?: BiomarkerValueWhereUniqueInput | BiomarkerValueWhereUniqueInput[]
    delete?: BiomarkerValueWhereUniqueInput | BiomarkerValueWhereUniqueInput[]
    connect?: BiomarkerValueWhereUniqueInput | BiomarkerValueWhereUniqueInput[]
    update?: BiomarkerValueUpdateWithWhereUniqueWithoutHealthReportInput | BiomarkerValueUpdateWithWhereUniqueWithoutHealthReportInput[]
    updateMany?: BiomarkerValueUpdateManyWithWhereWithoutHealthReportInput | BiomarkerValueUpdateManyWithWhereWithoutHealthReportInput[]
    deleteMany?: BiomarkerValueScalarWhereInput | BiomarkerValueScalarWhereInput[]
  }

  export type BiomarkerValueUncheckedUpdateManyWithoutHealthReportNestedInput = {
    create?: XOR<BiomarkerValueCreateWithoutHealthReportInput, BiomarkerValueUncheckedCreateWithoutHealthReportInput> | BiomarkerValueCreateWithoutHealthReportInput[] | BiomarkerValueUncheckedCreateWithoutHealthReportInput[]
    connectOrCreate?: BiomarkerValueCreateOrConnectWithoutHealthReportInput | BiomarkerValueCreateOrConnectWithoutHealthReportInput[]
    upsert?: BiomarkerValueUpsertWithWhereUniqueWithoutHealthReportInput | BiomarkerValueUpsertWithWhereUniqueWithoutHealthReportInput[]
    createMany?: BiomarkerValueCreateManyHealthReportInputEnvelope
    set?: BiomarkerValueWhereUniqueInput | BiomarkerValueWhereUniqueInput[]
    disconnect?: BiomarkerValueWhereUniqueInput | BiomarkerValueWhereUniqueInput[]
    delete?: BiomarkerValueWhereUniqueInput | BiomarkerValueWhereUniqueInput[]
    connect?: BiomarkerValueWhereUniqueInput | BiomarkerValueWhereUniqueInput[]
    update?: BiomarkerValueUpdateWithWhereUniqueWithoutHealthReportInput | BiomarkerValueUpdateWithWhereUniqueWithoutHealthReportInput[]
    updateMany?: BiomarkerValueUpdateManyWithWhereWithoutHealthReportInput | BiomarkerValueUpdateManyWithWhereWithoutHealthReportInput[]
    deleteMany?: BiomarkerValueScalarWhereInput | BiomarkerValueScalarWhereInput[]
  }

  export type HealthReportCreateNestedOneWithoutBiomarkersInput = {
    create?: XOR<HealthReportCreateWithoutBiomarkersInput, HealthReportUncheckedCreateWithoutBiomarkersInput>
    connectOrCreate?: HealthReportCreateOrConnectWithoutBiomarkersInput
    connect?: HealthReportWhereUniqueInput
  }

  export type BiomarkerCreateNestedOneWithoutValuesInput = {
    create?: XOR<BiomarkerCreateWithoutValuesInput, BiomarkerUncheckedCreateWithoutValuesInput>
    connectOrCreate?: BiomarkerCreateOrConnectWithoutValuesInput
    connect?: BiomarkerWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type HealthReportUpdateOneRequiredWithoutBiomarkersNestedInput = {
    create?: XOR<HealthReportCreateWithoutBiomarkersInput, HealthReportUncheckedCreateWithoutBiomarkersInput>
    connectOrCreate?: HealthReportCreateOrConnectWithoutBiomarkersInput
    upsert?: HealthReportUpsertWithoutBiomarkersInput
    connect?: HealthReportWhereUniqueInput
    update?: XOR<XOR<HealthReportUpdateToOneWithWhereWithoutBiomarkersInput, HealthReportUpdateWithoutBiomarkersInput>, HealthReportUncheckedUpdateWithoutBiomarkersInput>
  }

  export type BiomarkerUpdateOneRequiredWithoutValuesNestedInput = {
    create?: XOR<BiomarkerCreateWithoutValuesInput, BiomarkerUncheckedCreateWithoutValuesInput>
    connectOrCreate?: BiomarkerCreateOrConnectWithoutValuesInput
    upsert?: BiomarkerUpsertWithoutValuesInput
    connect?: BiomarkerWhereUniqueInput
    update?: XOR<XOR<BiomarkerUpdateToOneWithWhereWithoutValuesInput, BiomarkerUpdateWithoutValuesInput>, BiomarkerUncheckedUpdateWithoutValuesInput>
  }

  export type BiomarkerValueCreateNestedManyWithoutBiomarkerInput = {
    create?: XOR<BiomarkerValueCreateWithoutBiomarkerInput, BiomarkerValueUncheckedCreateWithoutBiomarkerInput> | BiomarkerValueCreateWithoutBiomarkerInput[] | BiomarkerValueUncheckedCreateWithoutBiomarkerInput[]
    connectOrCreate?: BiomarkerValueCreateOrConnectWithoutBiomarkerInput | BiomarkerValueCreateOrConnectWithoutBiomarkerInput[]
    createMany?: BiomarkerValueCreateManyBiomarkerInputEnvelope
    connect?: BiomarkerValueWhereUniqueInput | BiomarkerValueWhereUniqueInput[]
  }

  export type CorrelationCreateNestedManyWithoutBiomarkerInput = {
    create?: XOR<CorrelationCreateWithoutBiomarkerInput, CorrelationUncheckedCreateWithoutBiomarkerInput> | CorrelationCreateWithoutBiomarkerInput[] | CorrelationUncheckedCreateWithoutBiomarkerInput[]
    connectOrCreate?: CorrelationCreateOrConnectWithoutBiomarkerInput | CorrelationCreateOrConnectWithoutBiomarkerInput[]
    createMany?: CorrelationCreateManyBiomarkerInputEnvelope
    connect?: CorrelationWhereUniqueInput | CorrelationWhereUniqueInput[]
  }

  export type BiomarkerValueUncheckedCreateNestedManyWithoutBiomarkerInput = {
    create?: XOR<BiomarkerValueCreateWithoutBiomarkerInput, BiomarkerValueUncheckedCreateWithoutBiomarkerInput> | BiomarkerValueCreateWithoutBiomarkerInput[] | BiomarkerValueUncheckedCreateWithoutBiomarkerInput[]
    connectOrCreate?: BiomarkerValueCreateOrConnectWithoutBiomarkerInput | BiomarkerValueCreateOrConnectWithoutBiomarkerInput[]
    createMany?: BiomarkerValueCreateManyBiomarkerInputEnvelope
    connect?: BiomarkerValueWhereUniqueInput | BiomarkerValueWhereUniqueInput[]
  }

  export type CorrelationUncheckedCreateNestedManyWithoutBiomarkerInput = {
    create?: XOR<CorrelationCreateWithoutBiomarkerInput, CorrelationUncheckedCreateWithoutBiomarkerInput> | CorrelationCreateWithoutBiomarkerInput[] | CorrelationUncheckedCreateWithoutBiomarkerInput[]
    connectOrCreate?: CorrelationCreateOrConnectWithoutBiomarkerInput | CorrelationCreateOrConnectWithoutBiomarkerInput[]
    createMany?: CorrelationCreateManyBiomarkerInputEnvelope
    connect?: CorrelationWhereUniqueInput | CorrelationWhereUniqueInput[]
  }

  export type BiomarkerValueUpdateManyWithoutBiomarkerNestedInput = {
    create?: XOR<BiomarkerValueCreateWithoutBiomarkerInput, BiomarkerValueUncheckedCreateWithoutBiomarkerInput> | BiomarkerValueCreateWithoutBiomarkerInput[] | BiomarkerValueUncheckedCreateWithoutBiomarkerInput[]
    connectOrCreate?: BiomarkerValueCreateOrConnectWithoutBiomarkerInput | BiomarkerValueCreateOrConnectWithoutBiomarkerInput[]
    upsert?: BiomarkerValueUpsertWithWhereUniqueWithoutBiomarkerInput | BiomarkerValueUpsertWithWhereUniqueWithoutBiomarkerInput[]
    createMany?: BiomarkerValueCreateManyBiomarkerInputEnvelope
    set?: BiomarkerValueWhereUniqueInput | BiomarkerValueWhereUniqueInput[]
    disconnect?: BiomarkerValueWhereUniqueInput | BiomarkerValueWhereUniqueInput[]
    delete?: BiomarkerValueWhereUniqueInput | BiomarkerValueWhereUniqueInput[]
    connect?: BiomarkerValueWhereUniqueInput | BiomarkerValueWhereUniqueInput[]
    update?: BiomarkerValueUpdateWithWhereUniqueWithoutBiomarkerInput | BiomarkerValueUpdateWithWhereUniqueWithoutBiomarkerInput[]
    updateMany?: BiomarkerValueUpdateManyWithWhereWithoutBiomarkerInput | BiomarkerValueUpdateManyWithWhereWithoutBiomarkerInput[]
    deleteMany?: BiomarkerValueScalarWhereInput | BiomarkerValueScalarWhereInput[]
  }

  export type CorrelationUpdateManyWithoutBiomarkerNestedInput = {
    create?: XOR<CorrelationCreateWithoutBiomarkerInput, CorrelationUncheckedCreateWithoutBiomarkerInput> | CorrelationCreateWithoutBiomarkerInput[] | CorrelationUncheckedCreateWithoutBiomarkerInput[]
    connectOrCreate?: CorrelationCreateOrConnectWithoutBiomarkerInput | CorrelationCreateOrConnectWithoutBiomarkerInput[]
    upsert?: CorrelationUpsertWithWhereUniqueWithoutBiomarkerInput | CorrelationUpsertWithWhereUniqueWithoutBiomarkerInput[]
    createMany?: CorrelationCreateManyBiomarkerInputEnvelope
    set?: CorrelationWhereUniqueInput | CorrelationWhereUniqueInput[]
    disconnect?: CorrelationWhereUniqueInput | CorrelationWhereUniqueInput[]
    delete?: CorrelationWhereUniqueInput | CorrelationWhereUniqueInput[]
    connect?: CorrelationWhereUniqueInput | CorrelationWhereUniqueInput[]
    update?: CorrelationUpdateWithWhereUniqueWithoutBiomarkerInput | CorrelationUpdateWithWhereUniqueWithoutBiomarkerInput[]
    updateMany?: CorrelationUpdateManyWithWhereWithoutBiomarkerInput | CorrelationUpdateManyWithWhereWithoutBiomarkerInput[]
    deleteMany?: CorrelationScalarWhereInput | CorrelationScalarWhereInput[]
  }

  export type BiomarkerValueUncheckedUpdateManyWithoutBiomarkerNestedInput = {
    create?: XOR<BiomarkerValueCreateWithoutBiomarkerInput, BiomarkerValueUncheckedCreateWithoutBiomarkerInput> | BiomarkerValueCreateWithoutBiomarkerInput[] | BiomarkerValueUncheckedCreateWithoutBiomarkerInput[]
    connectOrCreate?: BiomarkerValueCreateOrConnectWithoutBiomarkerInput | BiomarkerValueCreateOrConnectWithoutBiomarkerInput[]
    upsert?: BiomarkerValueUpsertWithWhereUniqueWithoutBiomarkerInput | BiomarkerValueUpsertWithWhereUniqueWithoutBiomarkerInput[]
    createMany?: BiomarkerValueCreateManyBiomarkerInputEnvelope
    set?: BiomarkerValueWhereUniqueInput | BiomarkerValueWhereUniqueInput[]
    disconnect?: BiomarkerValueWhereUniqueInput | BiomarkerValueWhereUniqueInput[]
    delete?: BiomarkerValueWhereUniqueInput | BiomarkerValueWhereUniqueInput[]
    connect?: BiomarkerValueWhereUniqueInput | BiomarkerValueWhereUniqueInput[]
    update?: BiomarkerValueUpdateWithWhereUniqueWithoutBiomarkerInput | BiomarkerValueUpdateWithWhereUniqueWithoutBiomarkerInput[]
    updateMany?: BiomarkerValueUpdateManyWithWhereWithoutBiomarkerInput | BiomarkerValueUpdateManyWithWhereWithoutBiomarkerInput[]
    deleteMany?: BiomarkerValueScalarWhereInput | BiomarkerValueScalarWhereInput[]
  }

  export type CorrelationUncheckedUpdateManyWithoutBiomarkerNestedInput = {
    create?: XOR<CorrelationCreateWithoutBiomarkerInput, CorrelationUncheckedCreateWithoutBiomarkerInput> | CorrelationCreateWithoutBiomarkerInput[] | CorrelationUncheckedCreateWithoutBiomarkerInput[]
    connectOrCreate?: CorrelationCreateOrConnectWithoutBiomarkerInput | CorrelationCreateOrConnectWithoutBiomarkerInput[]
    upsert?: CorrelationUpsertWithWhereUniqueWithoutBiomarkerInput | CorrelationUpsertWithWhereUniqueWithoutBiomarkerInput[]
    createMany?: CorrelationCreateManyBiomarkerInputEnvelope
    set?: CorrelationWhereUniqueInput | CorrelationWhereUniqueInput[]
    disconnect?: CorrelationWhereUniqueInput | CorrelationWhereUniqueInput[]
    delete?: CorrelationWhereUniqueInput | CorrelationWhereUniqueInput[]
    connect?: CorrelationWhereUniqueInput | CorrelationWhereUniqueInput[]
    update?: CorrelationUpdateWithWhereUniqueWithoutBiomarkerInput | CorrelationUpdateWithWhereUniqueWithoutBiomarkerInput[]
    updateMany?: CorrelationUpdateManyWithWhereWithoutBiomarkerInput | CorrelationUpdateManyWithWhereWithoutBiomarkerInput[]
    deleteMany?: CorrelationScalarWhereInput | CorrelationScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutSymptomsInput = {
    create?: XOR<UserCreateWithoutSymptomsInput, UserUncheckedCreateWithoutSymptomsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSymptomsInput
    connect?: UserWhereUniqueInput
  }

  export type CorrelationCreateNestedManyWithoutSymptomInput = {
    create?: XOR<CorrelationCreateWithoutSymptomInput, CorrelationUncheckedCreateWithoutSymptomInput> | CorrelationCreateWithoutSymptomInput[] | CorrelationUncheckedCreateWithoutSymptomInput[]
    connectOrCreate?: CorrelationCreateOrConnectWithoutSymptomInput | CorrelationCreateOrConnectWithoutSymptomInput[]
    createMany?: CorrelationCreateManySymptomInputEnvelope
    connect?: CorrelationWhereUniqueInput | CorrelationWhereUniqueInput[]
  }

  export type CorrelationUncheckedCreateNestedManyWithoutSymptomInput = {
    create?: XOR<CorrelationCreateWithoutSymptomInput, CorrelationUncheckedCreateWithoutSymptomInput> | CorrelationCreateWithoutSymptomInput[] | CorrelationUncheckedCreateWithoutSymptomInput[]
    connectOrCreate?: CorrelationCreateOrConnectWithoutSymptomInput | CorrelationCreateOrConnectWithoutSymptomInput[]
    createMany?: CorrelationCreateManySymptomInputEnvelope
    connect?: CorrelationWhereUniqueInput | CorrelationWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutSymptomsNestedInput = {
    create?: XOR<UserCreateWithoutSymptomsInput, UserUncheckedCreateWithoutSymptomsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSymptomsInput
    upsert?: UserUpsertWithoutSymptomsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSymptomsInput, UserUpdateWithoutSymptomsInput>, UserUncheckedUpdateWithoutSymptomsInput>
  }

  export type CorrelationUpdateManyWithoutSymptomNestedInput = {
    create?: XOR<CorrelationCreateWithoutSymptomInput, CorrelationUncheckedCreateWithoutSymptomInput> | CorrelationCreateWithoutSymptomInput[] | CorrelationUncheckedCreateWithoutSymptomInput[]
    connectOrCreate?: CorrelationCreateOrConnectWithoutSymptomInput | CorrelationCreateOrConnectWithoutSymptomInput[]
    upsert?: CorrelationUpsertWithWhereUniqueWithoutSymptomInput | CorrelationUpsertWithWhereUniqueWithoutSymptomInput[]
    createMany?: CorrelationCreateManySymptomInputEnvelope
    set?: CorrelationWhereUniqueInput | CorrelationWhereUniqueInput[]
    disconnect?: CorrelationWhereUniqueInput | CorrelationWhereUniqueInput[]
    delete?: CorrelationWhereUniqueInput | CorrelationWhereUniqueInput[]
    connect?: CorrelationWhereUniqueInput | CorrelationWhereUniqueInput[]
    update?: CorrelationUpdateWithWhereUniqueWithoutSymptomInput | CorrelationUpdateWithWhereUniqueWithoutSymptomInput[]
    updateMany?: CorrelationUpdateManyWithWhereWithoutSymptomInput | CorrelationUpdateManyWithWhereWithoutSymptomInput[]
    deleteMany?: CorrelationScalarWhereInput | CorrelationScalarWhereInput[]
  }

  export type CorrelationUncheckedUpdateManyWithoutSymptomNestedInput = {
    create?: XOR<CorrelationCreateWithoutSymptomInput, CorrelationUncheckedCreateWithoutSymptomInput> | CorrelationCreateWithoutSymptomInput[] | CorrelationUncheckedCreateWithoutSymptomInput[]
    connectOrCreate?: CorrelationCreateOrConnectWithoutSymptomInput | CorrelationCreateOrConnectWithoutSymptomInput[]
    upsert?: CorrelationUpsertWithWhereUniqueWithoutSymptomInput | CorrelationUpsertWithWhereUniqueWithoutSymptomInput[]
    createMany?: CorrelationCreateManySymptomInputEnvelope
    set?: CorrelationWhereUniqueInput | CorrelationWhereUniqueInput[]
    disconnect?: CorrelationWhereUniqueInput | CorrelationWhereUniqueInput[]
    delete?: CorrelationWhereUniqueInput | CorrelationWhereUniqueInput[]
    connect?: CorrelationWhereUniqueInput | CorrelationWhereUniqueInput[]
    update?: CorrelationUpdateWithWhereUniqueWithoutSymptomInput | CorrelationUpdateWithWhereUniqueWithoutSymptomInput[]
    updateMany?: CorrelationUpdateManyWithWhereWithoutSymptomInput | CorrelationUpdateManyWithWhereWithoutSymptomInput[]
    deleteMany?: CorrelationScalarWhereInput | CorrelationScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutMedicationsInput = {
    create?: XOR<UserCreateWithoutMedicationsInput, UserUncheckedCreateWithoutMedicationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMedicationsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutMedicationsNestedInput = {
    create?: XOR<UserCreateWithoutMedicationsInput, UserUncheckedCreateWithoutMedicationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMedicationsInput
    upsert?: UserUpsertWithoutMedicationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMedicationsInput, UserUpdateWithoutMedicationsInput>, UserUncheckedUpdateWithoutMedicationsInput>
  }

  export type BiomarkerCreateNestedOneWithoutCorrelationsInput = {
    create?: XOR<BiomarkerCreateWithoutCorrelationsInput, BiomarkerUncheckedCreateWithoutCorrelationsInput>
    connectOrCreate?: BiomarkerCreateOrConnectWithoutCorrelationsInput
    connect?: BiomarkerWhereUniqueInput
  }

  export type SymptomCreateNestedOneWithoutCorrelationsInput = {
    create?: XOR<SymptomCreateWithoutCorrelationsInput, SymptomUncheckedCreateWithoutCorrelationsInput>
    connectOrCreate?: SymptomCreateOrConnectWithoutCorrelationsInput
    connect?: SymptomWhereUniqueInput
  }

  export type BiomarkerUpdateOneRequiredWithoutCorrelationsNestedInput = {
    create?: XOR<BiomarkerCreateWithoutCorrelationsInput, BiomarkerUncheckedCreateWithoutCorrelationsInput>
    connectOrCreate?: BiomarkerCreateOrConnectWithoutCorrelationsInput
    upsert?: BiomarkerUpsertWithoutCorrelationsInput
    connect?: BiomarkerWhereUniqueInput
    update?: XOR<XOR<BiomarkerUpdateToOneWithWhereWithoutCorrelationsInput, BiomarkerUpdateWithoutCorrelationsInput>, BiomarkerUncheckedUpdateWithoutCorrelationsInput>
  }

  export type SymptomUpdateOneRequiredWithoutCorrelationsNestedInput = {
    create?: XOR<SymptomCreateWithoutCorrelationsInput, SymptomUncheckedCreateWithoutCorrelationsInput>
    connectOrCreate?: SymptomCreateOrConnectWithoutCorrelationsInput
    upsert?: SymptomUpsertWithoutCorrelationsInput
    connect?: SymptomWhereUniqueInput
    update?: XOR<XOR<SymptomUpdateToOneWithWhereWithoutCorrelationsInput, SymptomUpdateWithoutCorrelationsInput>, SymptomUncheckedUpdateWithoutCorrelationsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type HealthReportCreateWithoutUserInput = {
    id?: string
    reportType: string
    collectionDate: Date | string
    provider?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    biomarkers?: BiomarkerValueCreateNestedManyWithoutHealthReportInput
  }

  export type HealthReportUncheckedCreateWithoutUserInput = {
    id?: string
    reportType: string
    collectionDate: Date | string
    provider?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    biomarkers?: BiomarkerValueUncheckedCreateNestedManyWithoutHealthReportInput
  }

  export type HealthReportCreateOrConnectWithoutUserInput = {
    where: HealthReportWhereUniqueInput
    create: XOR<HealthReportCreateWithoutUserInput, HealthReportUncheckedCreateWithoutUserInput>
  }

  export type HealthReportCreateManyUserInputEnvelope = {
    data: HealthReportCreateManyUserInput | HealthReportCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SymptomCreateWithoutUserInput = {
    id?: string
    name: string
    severity: number
    startDate: Date | string
    endDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    correlations?: CorrelationCreateNestedManyWithoutSymptomInput
  }

  export type SymptomUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    severity: number
    startDate: Date | string
    endDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    correlations?: CorrelationUncheckedCreateNestedManyWithoutSymptomInput
  }

  export type SymptomCreateOrConnectWithoutUserInput = {
    where: SymptomWhereUniqueInput
    create: XOR<SymptomCreateWithoutUserInput, SymptomUncheckedCreateWithoutUserInput>
  }

  export type SymptomCreateManyUserInputEnvelope = {
    data: SymptomCreateManyUserInput | SymptomCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MedicationCreateWithoutUserInput = {
    id?: string
    name: string
    dosage?: string | null
    frequency?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MedicationUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    dosage?: string | null
    frequency?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MedicationCreateOrConnectWithoutUserInput = {
    where: MedicationWhereUniqueInput
    create: XOR<MedicationCreateWithoutUserInput, MedicationUncheckedCreateWithoutUserInput>
  }

  export type MedicationCreateManyUserInputEnvelope = {
    data: MedicationCreateManyUserInput | MedicationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type HealthReportUpsertWithWhereUniqueWithoutUserInput = {
    where: HealthReportWhereUniqueInput
    update: XOR<HealthReportUpdateWithoutUserInput, HealthReportUncheckedUpdateWithoutUserInput>
    create: XOR<HealthReportCreateWithoutUserInput, HealthReportUncheckedCreateWithoutUserInput>
  }

  export type HealthReportUpdateWithWhereUniqueWithoutUserInput = {
    where: HealthReportWhereUniqueInput
    data: XOR<HealthReportUpdateWithoutUserInput, HealthReportUncheckedUpdateWithoutUserInput>
  }

  export type HealthReportUpdateManyWithWhereWithoutUserInput = {
    where: HealthReportScalarWhereInput
    data: XOR<HealthReportUpdateManyMutationInput, HealthReportUncheckedUpdateManyWithoutUserInput>
  }

  export type HealthReportScalarWhereInput = {
    AND?: HealthReportScalarWhereInput | HealthReportScalarWhereInput[]
    OR?: HealthReportScalarWhereInput[]
    NOT?: HealthReportScalarWhereInput | HealthReportScalarWhereInput[]
    id?: StringFilter<"HealthReport"> | string
    userId?: StringFilter<"HealthReport"> | string
    reportType?: StringFilter<"HealthReport"> | string
    collectionDate?: DateTimeFilter<"HealthReport"> | Date | string
    provider?: StringNullableFilter<"HealthReport"> | string | null
    notes?: StringNullableFilter<"HealthReport"> | string | null
    createdAt?: DateTimeFilter<"HealthReport"> | Date | string
    updatedAt?: DateTimeFilter<"HealthReport"> | Date | string
  }

  export type SymptomUpsertWithWhereUniqueWithoutUserInput = {
    where: SymptomWhereUniqueInput
    update: XOR<SymptomUpdateWithoutUserInput, SymptomUncheckedUpdateWithoutUserInput>
    create: XOR<SymptomCreateWithoutUserInput, SymptomUncheckedCreateWithoutUserInput>
  }

  export type SymptomUpdateWithWhereUniqueWithoutUserInput = {
    where: SymptomWhereUniqueInput
    data: XOR<SymptomUpdateWithoutUserInput, SymptomUncheckedUpdateWithoutUserInput>
  }

  export type SymptomUpdateManyWithWhereWithoutUserInput = {
    where: SymptomScalarWhereInput
    data: XOR<SymptomUpdateManyMutationInput, SymptomUncheckedUpdateManyWithoutUserInput>
  }

  export type SymptomScalarWhereInput = {
    AND?: SymptomScalarWhereInput | SymptomScalarWhereInput[]
    OR?: SymptomScalarWhereInput[]
    NOT?: SymptomScalarWhereInput | SymptomScalarWhereInput[]
    id?: StringFilter<"Symptom"> | string
    userId?: StringFilter<"Symptom"> | string
    name?: StringFilter<"Symptom"> | string
    severity?: IntFilter<"Symptom"> | number
    startDate?: DateTimeFilter<"Symptom"> | Date | string
    endDate?: DateTimeNullableFilter<"Symptom"> | Date | string | null
    notes?: StringNullableFilter<"Symptom"> | string | null
    createdAt?: DateTimeFilter<"Symptom"> | Date | string
    updatedAt?: DateTimeFilter<"Symptom"> | Date | string
  }

  export type MedicationUpsertWithWhereUniqueWithoutUserInput = {
    where: MedicationWhereUniqueInput
    update: XOR<MedicationUpdateWithoutUserInput, MedicationUncheckedUpdateWithoutUserInput>
    create: XOR<MedicationCreateWithoutUserInput, MedicationUncheckedCreateWithoutUserInput>
  }

  export type MedicationUpdateWithWhereUniqueWithoutUserInput = {
    where: MedicationWhereUniqueInput
    data: XOR<MedicationUpdateWithoutUserInput, MedicationUncheckedUpdateWithoutUserInput>
  }

  export type MedicationUpdateManyWithWhereWithoutUserInput = {
    where: MedicationScalarWhereInput
    data: XOR<MedicationUpdateManyMutationInput, MedicationUncheckedUpdateManyWithoutUserInput>
  }

  export type MedicationScalarWhereInput = {
    AND?: MedicationScalarWhereInput | MedicationScalarWhereInput[]
    OR?: MedicationScalarWhereInput[]
    NOT?: MedicationScalarWhereInput | MedicationScalarWhereInput[]
    id?: StringFilter<"Medication"> | string
    userId?: StringFilter<"Medication"> | string
    name?: StringFilter<"Medication"> | string
    dosage?: StringNullableFilter<"Medication"> | string | null
    frequency?: StringNullableFilter<"Medication"> | string | null
    startDate?: DateTimeFilter<"Medication"> | Date | string
    endDate?: DateTimeNullableFilter<"Medication"> | Date | string | null
    createdAt?: DateTimeFilter<"Medication"> | Date | string
    updatedAt?: DateTimeFilter<"Medication"> | Date | string
  }

  export type UserCreateWithoutHealthReportsInput = {
    id?: string
    email: string
    name?: string | null
    dateOfBirth?: Date | string | null
    sex?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    symptoms?: SymptomCreateNestedManyWithoutUserInput
    medications?: MedicationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutHealthReportsInput = {
    id?: string
    email: string
    name?: string | null
    dateOfBirth?: Date | string | null
    sex?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    symptoms?: SymptomUncheckedCreateNestedManyWithoutUserInput
    medications?: MedicationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutHealthReportsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutHealthReportsInput, UserUncheckedCreateWithoutHealthReportsInput>
  }

  export type BiomarkerValueCreateWithoutHealthReportInput = {
    id?: string
    value: number
    unit: string
    referenceMin?: number | null
    referenceMax?: number | null
    isAbnormal?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    biomarker: BiomarkerCreateNestedOneWithoutValuesInput
  }

  export type BiomarkerValueUncheckedCreateWithoutHealthReportInput = {
    id?: string
    biomarkerId: string
    value: number
    unit: string
    referenceMin?: number | null
    referenceMax?: number | null
    isAbnormal?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BiomarkerValueCreateOrConnectWithoutHealthReportInput = {
    where: BiomarkerValueWhereUniqueInput
    create: XOR<BiomarkerValueCreateWithoutHealthReportInput, BiomarkerValueUncheckedCreateWithoutHealthReportInput>
  }

  export type BiomarkerValueCreateManyHealthReportInputEnvelope = {
    data: BiomarkerValueCreateManyHealthReportInput | BiomarkerValueCreateManyHealthReportInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutHealthReportsInput = {
    update: XOR<UserUpdateWithoutHealthReportsInput, UserUncheckedUpdateWithoutHealthReportsInput>
    create: XOR<UserCreateWithoutHealthReportsInput, UserUncheckedCreateWithoutHealthReportsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutHealthReportsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutHealthReportsInput, UserUncheckedUpdateWithoutHealthReportsInput>
  }

  export type UserUpdateWithoutHealthReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    symptoms?: SymptomUpdateManyWithoutUserNestedInput
    medications?: MedicationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutHealthReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    symptoms?: SymptomUncheckedUpdateManyWithoutUserNestedInput
    medications?: MedicationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BiomarkerValueUpsertWithWhereUniqueWithoutHealthReportInput = {
    where: BiomarkerValueWhereUniqueInput
    update: XOR<BiomarkerValueUpdateWithoutHealthReportInput, BiomarkerValueUncheckedUpdateWithoutHealthReportInput>
    create: XOR<BiomarkerValueCreateWithoutHealthReportInput, BiomarkerValueUncheckedCreateWithoutHealthReportInput>
  }

  export type BiomarkerValueUpdateWithWhereUniqueWithoutHealthReportInput = {
    where: BiomarkerValueWhereUniqueInput
    data: XOR<BiomarkerValueUpdateWithoutHealthReportInput, BiomarkerValueUncheckedUpdateWithoutHealthReportInput>
  }

  export type BiomarkerValueUpdateManyWithWhereWithoutHealthReportInput = {
    where: BiomarkerValueScalarWhereInput
    data: XOR<BiomarkerValueUpdateManyMutationInput, BiomarkerValueUncheckedUpdateManyWithoutHealthReportInput>
  }

  export type BiomarkerValueScalarWhereInput = {
    AND?: BiomarkerValueScalarWhereInput | BiomarkerValueScalarWhereInput[]
    OR?: BiomarkerValueScalarWhereInput[]
    NOT?: BiomarkerValueScalarWhereInput | BiomarkerValueScalarWhereInput[]
    id?: StringFilter<"BiomarkerValue"> | string
    healthReportId?: StringFilter<"BiomarkerValue"> | string
    biomarkerId?: StringFilter<"BiomarkerValue"> | string
    value?: FloatFilter<"BiomarkerValue"> | number
    unit?: StringFilter<"BiomarkerValue"> | string
    referenceMin?: FloatNullableFilter<"BiomarkerValue"> | number | null
    referenceMax?: FloatNullableFilter<"BiomarkerValue"> | number | null
    isAbnormal?: BoolFilter<"BiomarkerValue"> | boolean
    createdAt?: DateTimeFilter<"BiomarkerValue"> | Date | string
    updatedAt?: DateTimeFilter<"BiomarkerValue"> | Date | string
  }

  export type HealthReportCreateWithoutBiomarkersInput = {
    id?: string
    reportType: string
    collectionDate: Date | string
    provider?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutHealthReportsInput
  }

  export type HealthReportUncheckedCreateWithoutBiomarkersInput = {
    id?: string
    userId: string
    reportType: string
    collectionDate: Date | string
    provider?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HealthReportCreateOrConnectWithoutBiomarkersInput = {
    where: HealthReportWhereUniqueInput
    create: XOR<HealthReportCreateWithoutBiomarkersInput, HealthReportUncheckedCreateWithoutBiomarkersInput>
  }

  export type BiomarkerCreateWithoutValuesInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    category: string
    unit: string
    defaultMinRange?: number | null
    defaultMaxRange?: number | null
    correlations?: CorrelationCreateNestedManyWithoutBiomarkerInput
  }

  export type BiomarkerUncheckedCreateWithoutValuesInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    category: string
    unit: string
    defaultMinRange?: number | null
    defaultMaxRange?: number | null
    correlations?: CorrelationUncheckedCreateNestedManyWithoutBiomarkerInput
  }

  export type BiomarkerCreateOrConnectWithoutValuesInput = {
    where: BiomarkerWhereUniqueInput
    create: XOR<BiomarkerCreateWithoutValuesInput, BiomarkerUncheckedCreateWithoutValuesInput>
  }

  export type HealthReportUpsertWithoutBiomarkersInput = {
    update: XOR<HealthReportUpdateWithoutBiomarkersInput, HealthReportUncheckedUpdateWithoutBiomarkersInput>
    create: XOR<HealthReportCreateWithoutBiomarkersInput, HealthReportUncheckedCreateWithoutBiomarkersInput>
    where?: HealthReportWhereInput
  }

  export type HealthReportUpdateToOneWithWhereWithoutBiomarkersInput = {
    where?: HealthReportWhereInput
    data: XOR<HealthReportUpdateWithoutBiomarkersInput, HealthReportUncheckedUpdateWithoutBiomarkersInput>
  }

  export type HealthReportUpdateWithoutBiomarkersInput = {
    id?: StringFieldUpdateOperationsInput | string
    reportType?: StringFieldUpdateOperationsInput | string
    collectionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutHealthReportsNestedInput
  }

  export type HealthReportUncheckedUpdateWithoutBiomarkersInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    reportType?: StringFieldUpdateOperationsInput | string
    collectionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BiomarkerUpsertWithoutValuesInput = {
    update: XOR<BiomarkerUpdateWithoutValuesInput, BiomarkerUncheckedUpdateWithoutValuesInput>
    create: XOR<BiomarkerCreateWithoutValuesInput, BiomarkerUncheckedCreateWithoutValuesInput>
    where?: BiomarkerWhereInput
  }

  export type BiomarkerUpdateToOneWithWhereWithoutValuesInput = {
    where?: BiomarkerWhereInput
    data: XOR<BiomarkerUpdateWithoutValuesInput, BiomarkerUncheckedUpdateWithoutValuesInput>
  }

  export type BiomarkerUpdateWithoutValuesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    defaultMinRange?: NullableFloatFieldUpdateOperationsInput | number | null
    defaultMaxRange?: NullableFloatFieldUpdateOperationsInput | number | null
    correlations?: CorrelationUpdateManyWithoutBiomarkerNestedInput
  }

  export type BiomarkerUncheckedUpdateWithoutValuesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    defaultMinRange?: NullableFloatFieldUpdateOperationsInput | number | null
    defaultMaxRange?: NullableFloatFieldUpdateOperationsInput | number | null
    correlations?: CorrelationUncheckedUpdateManyWithoutBiomarkerNestedInput
  }

  export type BiomarkerValueCreateWithoutBiomarkerInput = {
    id?: string
    value: number
    unit: string
    referenceMin?: number | null
    referenceMax?: number | null
    isAbnormal?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    healthReport: HealthReportCreateNestedOneWithoutBiomarkersInput
  }

  export type BiomarkerValueUncheckedCreateWithoutBiomarkerInput = {
    id?: string
    healthReportId: string
    value: number
    unit: string
    referenceMin?: number | null
    referenceMax?: number | null
    isAbnormal?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BiomarkerValueCreateOrConnectWithoutBiomarkerInput = {
    where: BiomarkerValueWhereUniqueInput
    create: XOR<BiomarkerValueCreateWithoutBiomarkerInput, BiomarkerValueUncheckedCreateWithoutBiomarkerInput>
  }

  export type BiomarkerValueCreateManyBiomarkerInputEnvelope = {
    data: BiomarkerValueCreateManyBiomarkerInput | BiomarkerValueCreateManyBiomarkerInput[]
    skipDuplicates?: boolean
  }

  export type CorrelationCreateWithoutBiomarkerInput = {
    id?: string
    strength: number
    direction: string
    confidence: number
    createdAt?: Date | string
    updatedAt?: Date | string
    symptom: SymptomCreateNestedOneWithoutCorrelationsInput
  }

  export type CorrelationUncheckedCreateWithoutBiomarkerInput = {
    id?: string
    symptomId: string
    strength: number
    direction: string
    confidence: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CorrelationCreateOrConnectWithoutBiomarkerInput = {
    where: CorrelationWhereUniqueInput
    create: XOR<CorrelationCreateWithoutBiomarkerInput, CorrelationUncheckedCreateWithoutBiomarkerInput>
  }

  export type CorrelationCreateManyBiomarkerInputEnvelope = {
    data: CorrelationCreateManyBiomarkerInput | CorrelationCreateManyBiomarkerInput[]
    skipDuplicates?: boolean
  }

  export type BiomarkerValueUpsertWithWhereUniqueWithoutBiomarkerInput = {
    where: BiomarkerValueWhereUniqueInput
    update: XOR<BiomarkerValueUpdateWithoutBiomarkerInput, BiomarkerValueUncheckedUpdateWithoutBiomarkerInput>
    create: XOR<BiomarkerValueCreateWithoutBiomarkerInput, BiomarkerValueUncheckedCreateWithoutBiomarkerInput>
  }

  export type BiomarkerValueUpdateWithWhereUniqueWithoutBiomarkerInput = {
    where: BiomarkerValueWhereUniqueInput
    data: XOR<BiomarkerValueUpdateWithoutBiomarkerInput, BiomarkerValueUncheckedUpdateWithoutBiomarkerInput>
  }

  export type BiomarkerValueUpdateManyWithWhereWithoutBiomarkerInput = {
    where: BiomarkerValueScalarWhereInput
    data: XOR<BiomarkerValueUpdateManyMutationInput, BiomarkerValueUncheckedUpdateManyWithoutBiomarkerInput>
  }

  export type CorrelationUpsertWithWhereUniqueWithoutBiomarkerInput = {
    where: CorrelationWhereUniqueInput
    update: XOR<CorrelationUpdateWithoutBiomarkerInput, CorrelationUncheckedUpdateWithoutBiomarkerInput>
    create: XOR<CorrelationCreateWithoutBiomarkerInput, CorrelationUncheckedCreateWithoutBiomarkerInput>
  }

  export type CorrelationUpdateWithWhereUniqueWithoutBiomarkerInput = {
    where: CorrelationWhereUniqueInput
    data: XOR<CorrelationUpdateWithoutBiomarkerInput, CorrelationUncheckedUpdateWithoutBiomarkerInput>
  }

  export type CorrelationUpdateManyWithWhereWithoutBiomarkerInput = {
    where: CorrelationScalarWhereInput
    data: XOR<CorrelationUpdateManyMutationInput, CorrelationUncheckedUpdateManyWithoutBiomarkerInput>
  }

  export type CorrelationScalarWhereInput = {
    AND?: CorrelationScalarWhereInput | CorrelationScalarWhereInput[]
    OR?: CorrelationScalarWhereInput[]
    NOT?: CorrelationScalarWhereInput | CorrelationScalarWhereInput[]
    id?: StringFilter<"Correlation"> | string
    biomarkerId?: StringFilter<"Correlation"> | string
    symptomId?: StringFilter<"Correlation"> | string
    strength?: FloatFilter<"Correlation"> | number
    direction?: StringFilter<"Correlation"> | string
    confidence?: FloatFilter<"Correlation"> | number
    createdAt?: DateTimeFilter<"Correlation"> | Date | string
    updatedAt?: DateTimeFilter<"Correlation"> | Date | string
  }

  export type UserCreateWithoutSymptomsInput = {
    id?: string
    email: string
    name?: string | null
    dateOfBirth?: Date | string | null
    sex?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    healthReports?: HealthReportCreateNestedManyWithoutUserInput
    medications?: MedicationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSymptomsInput = {
    id?: string
    email: string
    name?: string | null
    dateOfBirth?: Date | string | null
    sex?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    healthReports?: HealthReportUncheckedCreateNestedManyWithoutUserInput
    medications?: MedicationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSymptomsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSymptomsInput, UserUncheckedCreateWithoutSymptomsInput>
  }

  export type CorrelationCreateWithoutSymptomInput = {
    id?: string
    strength: number
    direction: string
    confidence: number
    createdAt?: Date | string
    updatedAt?: Date | string
    biomarker: BiomarkerCreateNestedOneWithoutCorrelationsInput
  }

  export type CorrelationUncheckedCreateWithoutSymptomInput = {
    id?: string
    biomarkerId: string
    strength: number
    direction: string
    confidence: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CorrelationCreateOrConnectWithoutSymptomInput = {
    where: CorrelationWhereUniqueInput
    create: XOR<CorrelationCreateWithoutSymptomInput, CorrelationUncheckedCreateWithoutSymptomInput>
  }

  export type CorrelationCreateManySymptomInputEnvelope = {
    data: CorrelationCreateManySymptomInput | CorrelationCreateManySymptomInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutSymptomsInput = {
    update: XOR<UserUpdateWithoutSymptomsInput, UserUncheckedUpdateWithoutSymptomsInput>
    create: XOR<UserCreateWithoutSymptomsInput, UserUncheckedCreateWithoutSymptomsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSymptomsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSymptomsInput, UserUncheckedUpdateWithoutSymptomsInput>
  }

  export type UserUpdateWithoutSymptomsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    healthReports?: HealthReportUpdateManyWithoutUserNestedInput
    medications?: MedicationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSymptomsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    healthReports?: HealthReportUncheckedUpdateManyWithoutUserNestedInput
    medications?: MedicationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CorrelationUpsertWithWhereUniqueWithoutSymptomInput = {
    where: CorrelationWhereUniqueInput
    update: XOR<CorrelationUpdateWithoutSymptomInput, CorrelationUncheckedUpdateWithoutSymptomInput>
    create: XOR<CorrelationCreateWithoutSymptomInput, CorrelationUncheckedCreateWithoutSymptomInput>
  }

  export type CorrelationUpdateWithWhereUniqueWithoutSymptomInput = {
    where: CorrelationWhereUniqueInput
    data: XOR<CorrelationUpdateWithoutSymptomInput, CorrelationUncheckedUpdateWithoutSymptomInput>
  }

  export type CorrelationUpdateManyWithWhereWithoutSymptomInput = {
    where: CorrelationScalarWhereInput
    data: XOR<CorrelationUpdateManyMutationInput, CorrelationUncheckedUpdateManyWithoutSymptomInput>
  }

  export type UserCreateWithoutMedicationsInput = {
    id?: string
    email: string
    name?: string | null
    dateOfBirth?: Date | string | null
    sex?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    healthReports?: HealthReportCreateNestedManyWithoutUserInput
    symptoms?: SymptomCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMedicationsInput = {
    id?: string
    email: string
    name?: string | null
    dateOfBirth?: Date | string | null
    sex?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    healthReports?: HealthReportUncheckedCreateNestedManyWithoutUserInput
    symptoms?: SymptomUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMedicationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMedicationsInput, UserUncheckedCreateWithoutMedicationsInput>
  }

  export type UserUpsertWithoutMedicationsInput = {
    update: XOR<UserUpdateWithoutMedicationsInput, UserUncheckedUpdateWithoutMedicationsInput>
    create: XOR<UserCreateWithoutMedicationsInput, UserUncheckedCreateWithoutMedicationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMedicationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMedicationsInput, UserUncheckedUpdateWithoutMedicationsInput>
  }

  export type UserUpdateWithoutMedicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    healthReports?: HealthReportUpdateManyWithoutUserNestedInput
    symptoms?: SymptomUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMedicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    healthReports?: HealthReportUncheckedUpdateManyWithoutUserNestedInput
    symptoms?: SymptomUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BiomarkerCreateWithoutCorrelationsInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    category: string
    unit: string
    defaultMinRange?: number | null
    defaultMaxRange?: number | null
    values?: BiomarkerValueCreateNestedManyWithoutBiomarkerInput
  }

  export type BiomarkerUncheckedCreateWithoutCorrelationsInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    category: string
    unit: string
    defaultMinRange?: number | null
    defaultMaxRange?: number | null
    values?: BiomarkerValueUncheckedCreateNestedManyWithoutBiomarkerInput
  }

  export type BiomarkerCreateOrConnectWithoutCorrelationsInput = {
    where: BiomarkerWhereUniqueInput
    create: XOR<BiomarkerCreateWithoutCorrelationsInput, BiomarkerUncheckedCreateWithoutCorrelationsInput>
  }

  export type SymptomCreateWithoutCorrelationsInput = {
    id?: string
    name: string
    severity: number
    startDate: Date | string
    endDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSymptomsInput
  }

  export type SymptomUncheckedCreateWithoutCorrelationsInput = {
    id?: string
    userId: string
    name: string
    severity: number
    startDate: Date | string
    endDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SymptomCreateOrConnectWithoutCorrelationsInput = {
    where: SymptomWhereUniqueInput
    create: XOR<SymptomCreateWithoutCorrelationsInput, SymptomUncheckedCreateWithoutCorrelationsInput>
  }

  export type BiomarkerUpsertWithoutCorrelationsInput = {
    update: XOR<BiomarkerUpdateWithoutCorrelationsInput, BiomarkerUncheckedUpdateWithoutCorrelationsInput>
    create: XOR<BiomarkerCreateWithoutCorrelationsInput, BiomarkerUncheckedCreateWithoutCorrelationsInput>
    where?: BiomarkerWhereInput
  }

  export type BiomarkerUpdateToOneWithWhereWithoutCorrelationsInput = {
    where?: BiomarkerWhereInput
    data: XOR<BiomarkerUpdateWithoutCorrelationsInput, BiomarkerUncheckedUpdateWithoutCorrelationsInput>
  }

  export type BiomarkerUpdateWithoutCorrelationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    defaultMinRange?: NullableFloatFieldUpdateOperationsInput | number | null
    defaultMaxRange?: NullableFloatFieldUpdateOperationsInput | number | null
    values?: BiomarkerValueUpdateManyWithoutBiomarkerNestedInput
  }

  export type BiomarkerUncheckedUpdateWithoutCorrelationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    defaultMinRange?: NullableFloatFieldUpdateOperationsInput | number | null
    defaultMaxRange?: NullableFloatFieldUpdateOperationsInput | number | null
    values?: BiomarkerValueUncheckedUpdateManyWithoutBiomarkerNestedInput
  }

  export type SymptomUpsertWithoutCorrelationsInput = {
    update: XOR<SymptomUpdateWithoutCorrelationsInput, SymptomUncheckedUpdateWithoutCorrelationsInput>
    create: XOR<SymptomCreateWithoutCorrelationsInput, SymptomUncheckedCreateWithoutCorrelationsInput>
    where?: SymptomWhereInput
  }

  export type SymptomUpdateToOneWithWhereWithoutCorrelationsInput = {
    where?: SymptomWhereInput
    data: XOR<SymptomUpdateWithoutCorrelationsInput, SymptomUncheckedUpdateWithoutCorrelationsInput>
  }

  export type SymptomUpdateWithoutCorrelationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    severity?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSymptomsNestedInput
  }

  export type SymptomUncheckedUpdateWithoutCorrelationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    severity?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HealthReportCreateManyUserInput = {
    id?: string
    reportType: string
    collectionDate: Date | string
    provider?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SymptomCreateManyUserInput = {
    id?: string
    name: string
    severity: number
    startDate: Date | string
    endDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MedicationCreateManyUserInput = {
    id?: string
    name: string
    dosage?: string | null
    frequency?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HealthReportUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    reportType?: StringFieldUpdateOperationsInput | string
    collectionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    biomarkers?: BiomarkerValueUpdateManyWithoutHealthReportNestedInput
  }

  export type HealthReportUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    reportType?: StringFieldUpdateOperationsInput | string
    collectionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    biomarkers?: BiomarkerValueUncheckedUpdateManyWithoutHealthReportNestedInput
  }

  export type HealthReportUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    reportType?: StringFieldUpdateOperationsInput | string
    collectionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SymptomUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    severity?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    correlations?: CorrelationUpdateManyWithoutSymptomNestedInput
  }

  export type SymptomUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    severity?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    correlations?: CorrelationUncheckedUpdateManyWithoutSymptomNestedInput
  }

  export type SymptomUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    severity?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    dosage?: NullableStringFieldUpdateOperationsInput | string | null
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    dosage?: NullableStringFieldUpdateOperationsInput | string | null
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    dosage?: NullableStringFieldUpdateOperationsInput | string | null
    frequency?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BiomarkerValueCreateManyHealthReportInput = {
    id?: string
    biomarkerId: string
    value: number
    unit: string
    referenceMin?: number | null
    referenceMax?: number | null
    isAbnormal?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BiomarkerValueUpdateWithoutHealthReportInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    referenceMin?: NullableFloatFieldUpdateOperationsInput | number | null
    referenceMax?: NullableFloatFieldUpdateOperationsInput | number | null
    isAbnormal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    biomarker?: BiomarkerUpdateOneRequiredWithoutValuesNestedInput
  }

  export type BiomarkerValueUncheckedUpdateWithoutHealthReportInput = {
    id?: StringFieldUpdateOperationsInput | string
    biomarkerId?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    referenceMin?: NullableFloatFieldUpdateOperationsInput | number | null
    referenceMax?: NullableFloatFieldUpdateOperationsInput | number | null
    isAbnormal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BiomarkerValueUncheckedUpdateManyWithoutHealthReportInput = {
    id?: StringFieldUpdateOperationsInput | string
    biomarkerId?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    referenceMin?: NullableFloatFieldUpdateOperationsInput | number | null
    referenceMax?: NullableFloatFieldUpdateOperationsInput | number | null
    isAbnormal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BiomarkerValueCreateManyBiomarkerInput = {
    id?: string
    healthReportId: string
    value: number
    unit: string
    referenceMin?: number | null
    referenceMax?: number | null
    isAbnormal?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CorrelationCreateManyBiomarkerInput = {
    id?: string
    symptomId: string
    strength: number
    direction: string
    confidence: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BiomarkerValueUpdateWithoutBiomarkerInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    referenceMin?: NullableFloatFieldUpdateOperationsInput | number | null
    referenceMax?: NullableFloatFieldUpdateOperationsInput | number | null
    isAbnormal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    healthReport?: HealthReportUpdateOneRequiredWithoutBiomarkersNestedInput
  }

  export type BiomarkerValueUncheckedUpdateWithoutBiomarkerInput = {
    id?: StringFieldUpdateOperationsInput | string
    healthReportId?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    referenceMin?: NullableFloatFieldUpdateOperationsInput | number | null
    referenceMax?: NullableFloatFieldUpdateOperationsInput | number | null
    isAbnormal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BiomarkerValueUncheckedUpdateManyWithoutBiomarkerInput = {
    id?: StringFieldUpdateOperationsInput | string
    healthReportId?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    referenceMin?: NullableFloatFieldUpdateOperationsInput | number | null
    referenceMax?: NullableFloatFieldUpdateOperationsInput | number | null
    isAbnormal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CorrelationUpdateWithoutBiomarkerInput = {
    id?: StringFieldUpdateOperationsInput | string
    strength?: FloatFieldUpdateOperationsInput | number
    direction?: StringFieldUpdateOperationsInput | string
    confidence?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    symptom?: SymptomUpdateOneRequiredWithoutCorrelationsNestedInput
  }

  export type CorrelationUncheckedUpdateWithoutBiomarkerInput = {
    id?: StringFieldUpdateOperationsInput | string
    symptomId?: StringFieldUpdateOperationsInput | string
    strength?: FloatFieldUpdateOperationsInput | number
    direction?: StringFieldUpdateOperationsInput | string
    confidence?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CorrelationUncheckedUpdateManyWithoutBiomarkerInput = {
    id?: StringFieldUpdateOperationsInput | string
    symptomId?: StringFieldUpdateOperationsInput | string
    strength?: FloatFieldUpdateOperationsInput | number
    direction?: StringFieldUpdateOperationsInput | string
    confidence?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CorrelationCreateManySymptomInput = {
    id?: string
    biomarkerId: string
    strength: number
    direction: string
    confidence: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CorrelationUpdateWithoutSymptomInput = {
    id?: StringFieldUpdateOperationsInput | string
    strength?: FloatFieldUpdateOperationsInput | number
    direction?: StringFieldUpdateOperationsInput | string
    confidence?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    biomarker?: BiomarkerUpdateOneRequiredWithoutCorrelationsNestedInput
  }

  export type CorrelationUncheckedUpdateWithoutSymptomInput = {
    id?: StringFieldUpdateOperationsInput | string
    biomarkerId?: StringFieldUpdateOperationsInput | string
    strength?: FloatFieldUpdateOperationsInput | number
    direction?: StringFieldUpdateOperationsInput | string
    confidence?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CorrelationUncheckedUpdateManyWithoutSymptomInput = {
    id?: StringFieldUpdateOperationsInput | string
    biomarkerId?: StringFieldUpdateOperationsInput | string
    strength?: FloatFieldUpdateOperationsInput | number
    direction?: StringFieldUpdateOperationsInput | string
    confidence?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HealthReportCountOutputTypeDefaultArgs instead
     */
    export type HealthReportCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HealthReportCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BiomarkerCountOutputTypeDefaultArgs instead
     */
    export type BiomarkerCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BiomarkerCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SymptomCountOutputTypeDefaultArgs instead
     */
    export type SymptomCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SymptomCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HealthReportDefaultArgs instead
     */
    export type HealthReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HealthReportDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BiomarkerValueDefaultArgs instead
     */
    export type BiomarkerValueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BiomarkerValueDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BiomarkerDefaultArgs instead
     */
    export type BiomarkerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BiomarkerDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SymptomDefaultArgs instead
     */
    export type SymptomArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SymptomDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MedicationDefaultArgs instead
     */
    export type MedicationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MedicationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CorrelationDefaultArgs instead
     */
    export type CorrelationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CorrelationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RiskAssessmentDefaultArgs instead
     */
    export type RiskAssessmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RiskAssessmentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RecommendationDefaultArgs instead
     */
    export type RecommendationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RecommendationDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}